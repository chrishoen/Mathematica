(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)















(* Copyright 2002, 2003, 2004, 2005 by Renan Cabrera, David Park, 
  Jean-Francois Gouyet *)

Needs["Graphics`Colors`"]

BeginPackage["TensorCalculus3`Tensorial`"];





Tensor::usage="Tensor[A, upindices, downindices] represents a tensor with the label A and the given up and down indices. The list of up and down indices must be equal in length. Missing indices are indicated by Void.";

Void::usage = "Void is used to indicate a blank slot in the up or down tensor indices.";

Dif::usage=
  "Dif[index] is the internal representation for partial differentation of an index."

Cov::usage=
  "Cov[index] is the internal representation for covariant differentation of an index."

NestedTensor::usage="NestedTensor[expr] generates Tensor[Tensor[expr],{},{}]. This can be used to created unexpanded derivative expressions of expr, which are later expanded with UnnestTensor. NestedTensors cannot use commands such as EinsteinSum that depend upon parsing the term indices as the nested expression is inaccessible.";

UnnestTensor::usage="UnnestTensor converts derivatives containing nested Tensors into normal derivative expressions.";

SetDerivativeSymbols::usage=
  "SetDerivativeSymbols[{\",\", \";\", \"\[DifferentialD]\", \"\[DifferentialD]\", \"D\", \"d\",\"\[ScriptCapitalL]\"}] sets the output format derivative symbols to the list of characters. The list is {DifSym, CovSym, TotalDupSym, TotalDdownSym, AbsoluteDupSym, AbsoluteDdownSym, LieDSym}. The default values are as shown. To change one you must reset the entire list."



ToArrayValues::usage="ToArrayValues[expr] will convert the expression to a vector, matrix or array by expansion and substitution of any stored values.";

ContractArray::usage="ContractArray[tarray, {lev1, lev2}..] will contract the indicated pairs of level numbers in the tensor array tarray.";



BaseIndices::usage="BaseIndices is the current list of symbols or integers being used to index the coordinates.";

DeclareBaseIndices::usage="DeclareBaseIndices[indexlist] sets the number and values of the base indices. Examples: {1,2,3}, {0,1,2,3}, {t,x,y,z}. The number of base indices determines NDim, the dimension of the underlying vector space. The indices are stored in BaseIndices.";

NDim::usage="NDim is the current dimension of the space, obtained from the length of the BaseIndices list.";

BaseIndexQ::usage="BaseIndexQ[index] returns True if index has a base index value as its raw index and False otherwise. For example Cov[red[1]] returns True if 1 is one of the base indices.";



CircleTimes::usage="CircleTimes is used to represent full form tensor products. It maintains the order of tensor factors.";

LinearBreakout::usage="LinearBreakout[f1, f2,...][v1, v2,...][expr] will break out the linear terms of any expressions within expr that have heads matching the patterns fi over variables matching the patterns vj. Example:\n f[a x + b y]//LinearBreakout[f][x,y] \[Rule] a f[x] + b f[y]";

PushOnto::usage=
  "PushOnto[argslist, ontolist][expr] is a form of the Through command that pushes arguments only onto forms given in the ontolist.\nPushOnto[ontolist][(head)[args]] pushes args onto forms given in the ontolist"

CircleEvalRule::usage="CircleEvalRule resolves expressions like\n(v1\[CircleTimes]v2\[CircleTimes]v3\[CircleTimes]v4)[w1,,w3,] \[Rule] v2\[CircleTimes]v4 v1.w1 v3.w3 \ninto dot products and reduced tensor terms.";

EvaluateSlots::usage="EvaluateSlots[e, g][expr] will evaluate tensor products, involving CircleTimes, on a list of argument slots, which may contain Nulls. The tensor product and slots must be indicial expressions involving basis tensors e. g is the label for the metric tensor. It is assumed that shortcuts have been defined for e and g.";

BasisDotProductRules::usage="BasisDotProductRules[b, g] creates the dot product simplification rules for basis vectors. These convert dot products of basis vectors to the corresponding metric tensors. b is the label used for basis vectors and g is the label used for the metric tensor.";

ReverseBasisDotProductRules::usage="ReverseBasisDotProductRules[b, g] creates the rules that convert metric tensors into dot products of the basis vectors. b is the label used for basis vectors and g is the label used for the metric tensor.";

EvaluateDotProducts::usage="EvaluateDotProducts[e, g][expr] evaluates all Dot products in expr assuming that e are the basis vectors and g is the metric tensor.";

ConstructDirectProduct::usage="ConstructDirectProduct[expr] will convert a direct product of tensor slot expressions to an expression with a single set of slots. Example:\nS[w,x]\[CircleTimes]T[y,z]//ConstructDirectProduct \[Rule] (S\[CircleTimes]T)[w,x,y,z]. S and T may also be CircleTimes expressions involving basis vectors.";

GenerateBasisTensors::usage="GenerateBasisTensors[e, configuration] will generate the set of basis tensors on basis vectors e with a given configuration of up and down basis vectors. The configuration is specified by a String of u's and d's for up and down. It is assumed that tensor shortcuts have been defined for e.";

UsePartialDChainRule::usage="UsePartialDChainRule[coordtensor][expr] will rewrite single partial derivatives in expr using the chain rule with respect to coordtensor.\nUsePartialDChainRule[diffvar1, diffvar2][expr] will rewrite single or multiple partial derivatives with respect to diffvar2 using the chain rule on diffvar1.";

UseTotalDChainRule::usage="UseTotalDChainRule[coordtensor, labels][expr] will rewrite single total derivatives in expr using the chain rule with respect to coordtensor using labels as the standard set of labels.";



ParseTermIndices::usage="ParseTermIndices[term] will return the lists of indices:\n{dummies, {freeup, freedown}, bad}\n Dummies are indicies that occur up and down exactly once. Free indicies are ones that occur only once. All other indicies that appear in the term are bad.";

RawIndex::usage="RawIndex[index] will extract the raw index from a flavored and/or differentiated index. If the raw index is not a Symbol or Integer an error message is issued.";

RawIndex::notindex="`` is not a Symbol, Integer or Flavor.";

ExtractFreeIndices::usage="ExtractFreeIndices[expr] will generate a list, {{upindices...}, {downindices...}}, of free indices for expr. The up and down indices are sorted in standard order. Expr must be an equation with a sum of tensor terms on each side, or a simple sum of tensor terms. If the terms don't all have the same free indices an error message is generated and False is returned.";

FreeIndices::usage="FreeIndices::notmatched is a error message.";

FreeIndices::notmatched="The free indices are not the same in all terms of the expression or some terms have bad indices.";

SymbolicIndexQ::usage="SymbolicIndexQ[index] returns true if index is a Symbol or if index is flavor[i_Symbol] where flavor is a currently active flavor.";

RaiseIndex::usage="RaiseIndex[i,j][tensor] will raise the lower index i in tensor and rename it j.\nRaiseIndex[i,j][expr] will raise the index in all Tensors in the expr.";

RaiseIndex::noindex="`` is not a lower index in ``";

LowerIndex::usage="LowerIndex[i,j][tensor] will lower the upper index i in tensor and rename it j.\nLowerIndex[i,j][expr] will lower the index in all Tensors in the expr.";

LowerIndex::noindex="`` is not an upper index in ``";

ReplaceIndex::usage="ReplaceIndex[i,j][tensor] will replace the index i in tensor and rename it j.\nReplaceIndex[i,j][expr] will replace the index in all Tensors in the expr.";

ReplaceIndex::noindex="`` is not an index in ``";

IndexChange::usage="IndexChange[{{r, i}, {s, j}...}, sign:1][expr] will replace the first index in each pair list by the second index in the pair list and multiply the expression by sign, which has the default value of 1./nIndexChange[{r,i}, sign:1][expr] may be used in the case of a single index change. Only terms that contain all the indices to be changed will be affected. The flavor must be in the indices.";

UpDownSwap::usage="UpDownSwap[dummyindex][term] will swap the up-down positions of the dummy index in the term consisting of simple tensor products.";

DummySimplify::usage ="DummySimplify[expr] will attempt to simplify the dummy indices in the tensor expression to produce a minimum number of dummy indices.";

SimplifyTensorSum::usage="SimplifyTensorSum[sum] will check that all terms in a tensor sum have valid indices, that the free indices are the same in all terms, and will simplify the sum by using a minimum number of dummy indices.";

SimplifyTensorSum::badterm="Term `` contains bad indices.";

SimplifyTensorSum::free="Free indices are not the same in all terms.";

PatternReplaceIndex::usage="PatternReplaceIndex[newindexlist, pattern, checkdummies:True][expr] will replace terms in expr using pattern indices in the given pattern, using newindexlist as replacement dummies. If the head of expr is Plus, the routine is mapped onto the individual terms. The number of named index patterns in pattern must be the same as the number of new indices. The substitutions are performed in the sort order of the named index patterns. The pattern should correspond to a single term. The named index patterns should correspond to dummy indices in the entire expression. The routine will check that the pattern indices are dummies in the matched term unless the optional argument, checkdummies, is set to False. In that case it will also replace pattern indices elsewhere in expr.";

PatternReplaceIndex::dummies="Some pattern indices in `` are not dummies.";

PatternReplaceIndex::numindices="The number of pattern indices in `` does not agree with the number of newindices.";\



MapLevelParts::usage="MapLevelParts[function, {topposition, levelpositions}][expr] will map the function onto the selected level positions in an expression. Levelpositions is a list of the selected parts. The function is applied to them as a group and they are replaced with a single new expression. Other parts not specified in levelpositions are left unchanged.\nExample:\na + b + c + d + e // MapLevelParts[f, {{2,4,5}}] -> a + c + f[b + d + e]";

MapLevelPatterns::usage="MapLevelPatterns[function, {topposition, {pattern}}][expr] will map the function onto the selected level positions at topposition that match the pattern in an expression. The function is applied to these positions as a group and they are replaced with a single new expression. Other parts not specified in the level are left unchanged.\nExample:\nf[1] + f[2] + f[3] + f[4] // MapLevelPatterns[g, {{f[_?EvenQ]}}] -> f[1] + f[3] + g[f[2] + f[4]]";

MapLevelPatterns::nomatch="There were no matches for `` in ``";



SumExpansion::usage="SumExpansion[i,j,.., base:BaseIndices][expr] will sum on the indices, i, j,..., in the expression. The indices must carry their flavors. The expansions will be done on individual terms on both sides of an equation and within arrays. The range of the sum is over the base list which has the default value of BaseIndices.\nSumExpansion[{i,j,..}, base:BaseIndices][expr] may also be used.";

ArrayExpansion::usage="ArrayExpansion[i,j,.., base:BaseIndices][expr] will form an array on the indices, i, j,..., in the expression. The indices must carry their flavors. The first index will be at the highest level in the expansion array. The range of the expansion is over the base list which has the default value of BaseIndices.\nArrayExpansion[{i,j,..}, base:BaseIndices][expr] may also be used.";

SumArrayExpansion::subset="`` is not a subset of the BaseIndices ``";

EinsteinSum::usage="EinsteinSum[base:BaseIndices][expr] will do an Einstein summation individually on all terms on both sides of an equation, or all terms in a sum, or on a single term. The range of the sum is over the base list which has the default value of BaseIndices.";

EinsteinArray::usage="EinsteinArray[base:BaseIndices][expr] will do an array expansion on the free indices in the expression. The expansion will be done in the sort order of the free indices. The range of the expansion is over the BaseIndices.";

PartialSum::usage="PartialSum[baseindex, newindices][expr] will expand dummy summations of a tensor expression into components that have one or more baseindex and unexpanded remainders. The elements are returned as a sum. Newindices is a list of indices that are used to replace the existing free indices in the expression. Greek indices might be replaced with Latin indices to indicate a restricted further expansion. PartialSum is mapped over arrays, equations and sums.";

PartialSum::newindices="New indices ``, after removing freeindices ``, are insufficient to replace ``";

PartialSum::baseindex="The base index ``, is not in BaseIndices ``";

PartialArray::usage="PartialArray[baseindex, newindices][expr] will expand the free indices of a tensor expression into components that have one or more baseindex indices and an unexpanded remainder. The elements are returned as a List. Newindices is a list of indices that are used to replace the existing free indices in the expression. Greek indices might be replaced with Latin indices to indicate a restricted further expansion. PartialArray is mapped over arrays, equations and sums.";

PartialArray::newindices="New indices ``, after removing dummies ``, are insufficient to replace ``";

PartialArray::baseindex="The base index ``, is not in BaseIndices ``";

EinsteinArgument::usage="EinsteinArgument[x][expr] will expand coordinate tensors with the label x when used as arguments of functions.\nEinsteinArgument[x, f] will expand only on function heads f.";



IndexFlavors::usage="IndexFlavors is a list of the currently declared index flavors. It has the form {{flavorname, flavorform}...} where flavorname is a symbol, such as red or rocket, and flavorform is either an RGBColor or a header such as OverHat.";

DeclareIndexFlavor::usage="DeclareIndexFlavor[{flavorname, flavorform}] will add the index flavor to the IndexFlavors list and establish the Format for displaying indices with the given flavorname. If flavorform is an RGBColor, the index will be displayed in the given color, otherwise an index i will be displayed as flavorform[i], for example OverHat[i].";

ToFlavor::usage="ToFlavor[toflavor, fromflavor:Identity][expr] will convert Tensors in expr to the specified (toflavor) flavor of indices from fromflavor. Fromflavor is an optional argument with the value Automatic. Identity corresponds to indices with no flavor wrapper. Toflavor may be given the value Identity, in which case fromflavor indices are converted to unflavored indices.";

ClearIndexFlavor::usage="ClearIndexFlavor[flavor] will delete flavor from IndexFlavors and clear the associated Format definition.\nClearIndexFlavor[{flavor, form}]:= ClearIndexFlavor[flavor].";

Flavor::notflavor="`` is not a currently declared index flavor.";

IndexFlavorQ::usage="IndexFlavorQ[flavor] returns True if flavor is contained in the IndexFlavors list and False otherwise.";

GetIndexFlavor::usage="GetIndexFlavor[index] will extract the flavor of an index. It returns Identity for indexes without flavors. It returns $Failed if the flavor is not a currently declared flavor. It reaches inside Dif and Cov.";



ContractKroneckers::usage="ContractKroneckers[\[Delta]][expr] will contract all tensors with label \[Delta], assumed to be generalized Kroneckers, to give a numerical factor times a Kronecker on the free indices.";

ContractKroneckers::indices="Kronecker tensor `` does not have equal up and down indices.";

FullKroneckerExpand::usage="FullKroneckerExpand[\[Delta]][expr] will fully expand tensors with label \[Delta], assumed to be generalized Kroneckers, as first order Kroneckers.";

FullKroneckerExpand::indices="Kronecker tensor `` does not have equal up and down indices.";

PartialKroneckerExpand::usage="PartialKroneckerExpand[\[Delta], order, suborder, expandup:True][expr] will expand tensors with label \[Delta], assumed to be generalized Kroneckers, and with order up and down indices, in terms of \[Delta]s with suborder and (order - suborder) indices. The expansion is done on the first suborder up indices, unless the optional 4th argument is set to False, in which case the first suborder down indices are used.";

PartialKroneckerExpand::indices="Kronecker tensor `` does not have equal up and down indices.";

KroneckerAbsorb::usage="KroneckerAbsorb[\[Delta]][expr] will perform all replacement operations of first order mixed tensors with labels \[Delta], assumed to be Kronecker deltas.";

PermutationPseudotensor::usage="PermutationPseudotensor[n] will generate the array of values that correspond to the completely antisymmetric n-dimensional tensor. The Levi-Civita tensor may be constructed from it.";

PermutationSymbolRule::usage="PermutationSymbolRule[e] will substitute values for a permutation pseudotensor symbol with label e. For substitution to occur the indices must be all up or all down, must be base indices and must all be the same flavor. The base indices in their declared order will have a value of 1.";



MetricSimplify::usage="MetricSimplify[g][expr] will raise, lower or replace indices in product terms involving g and tensors in expr using g as the label for a metric tensor. The metric tensor can have down, up, up/down or down/up indices.\nMetricSimplify[g, True][expr] will enable metric simplification across Partial and Total derivatives.";



\!\(UseCoordinates::usage = \*"\"\<UseCoordinates[{x, y, z,...}, coord:x, flavor:Identity][expr] replaces the coordinate \!\(x\^i\) with the i'th symbol in the list everywhere in the expression. It also replaces \!\(dx\^i\) with d(i'th symbol) if they appear in the expression. coord is the coordinate label and is an optional argument with the default value x. Flavor is an optional argument with the default value of Identity. \\nUseCoordinates[coord:x, flavor:Identity][expr] uses the index symbols established with DeclareBaseIndices.\>\""; \)

CoordinatesToTensors::usage="CoordinatesToTensors[coordinatelist, label:x, flavor:Identity] will convert coordinate Symbols to the corresponding indexed tensors. Label and flavor are optional arguments that designate the tensor label and the index flavor. The order of the symbols in the coordinates list must correspond to the order of the items in BaseIndices";\





SymmetrizeSlots::usage="SymmetrizeSlots[label, order, symmetries][expr] will put indices in standard order for all tensors of the given label and order in expr. In the case of duplicate indices in antisymmetric slots the tensor will be set to zero. The symmetries are given by a list of symmetry specifications, {symm1, symm2,...}. Each symmetry specification is of the form {-1|1,{n1,n2,...}} where -1 is used for antisymmetry and 1 for symmetry. n1, n2 etc., are the slot numbers involved in the symmetry. If there is only a single symmetry it may be entered without the extra brackets.\nSymmetrizeSlots[][expr] will employ any TensorSymmetries that have been declared.";

SymmetrizePattern::usage="SymmetrizePattern[pattern, symmetries][expr] will permute the (anti)symmetrical indices in all terms matching the pattern such that they are ordered according to the pattern and the specified symmetries. The symmetries take the form\n{{-1|1, {index1, index2,\[Ellipsis]}}\[Ellipsis]} where -1 is used if the set of indices is antisymmetrical and 1 if they are symmetrical. For each term and symmetry set, the symmetry set is first sorted. The index values are then picked from the values in the corresponding position in the pattern. These are then changed to the sorted values of the set with the appropriate sign.\nindex1, index2,\[Ellipsis] may also be equal length lists of indices. In that case they are each treated as groups of indices that can be interchanged without internal rearrangement. \nSymmetrizePattern[][expr] automatically applies all the pattern symmetries that have been declared with DeclarePatternSymmetries.";

DeclareTensorSymmetries::usage="DeclareTensorSymmetries[label, order, symmetries] will store symmetry information about tensors in TensorSymmetries. The parameters are specfied as in SymmetrizeSlots. ";

DeclarePatternSymmetries::usage="DeclarePatternSymmetries[pattern, symmetries] declares a pattern symmetry that will be applied by the general command SymmetrizePattern[]. The symmetries are specified as in the SymmetrizePattern command.\nDeclarePatternSymmetries[{pattern, symmetries},..] allows multiple symmetries to be declared at once.";

TensorSymmetries::usage="TensorSymmetries is the Head for the specifications of tensor symmetries declared with DeclareTensorSymmetries.";

PatternSymmetries::usage="PatternSymmetries is a list of pattern symmetries that will all be applied with the SymmetrizePattern[] command.";

Symmetric::usage="Symmetric[ind][expr], calculates the symmetric tensor expression associated with expr for the index list ind.\nSymmetric[list1, list2,...][expr] calculates the symmetric tensor expression for multiple sets of symmetric indices.";

Symmetric::indices="Symmetric indices `` must be all be in the list of up, ``, or all in the list of down, ``, indices.";

AntiSymmetric::usage=" AntiSymmetric[ind][expr], calculates the  antisymmetric tensor expression associated with expr for the index list ind.\nAntiSymmetric[list1, list2,...][expr] calculates the antisymmetric tensor expression for multiple sets of antisymmetric indices.";

AntiSymmetric::indices="AntiSymmetric indices `` must be all be in the list of up, ``, or all in the list of down, ``, indices.";



DefineTensorShortcuts::usage="DefineTensorShortcuts[label, order] will define tensor input shortcuts for all the up/down configurations for tensors with the given label and of the given order. The shortcuts will be designated by appending successive u's or d's to the tensor label in the order of the tensor slots.\nDefineTensorShortcuts[T, 2] will define shortcuts with names Tuu, Tud, Tdu, Tdd. Then, for example,\nTdu[i, j] is the same as Tensor[T, {Void, j}, {i, Void}].\nDefineTensorShortcuts[{u, v, w,...}, order] will define shortcuts for a number of labels.\nDefineTensorShortcuts[{tensor(s), order}..] can be used to define a number of tensors of different orders.";

ClearTensorShortcuts::usage="ClearTensorShortcuts[label, order] will clear all tensor input shortcuts that were established with DefineTensorShortcuts[label, order].\nClearTensorShortcuts[{u, v, w,...}, order] will clear the shortcuts for a number of labels.\nClearTensorShortcuts[{tensor(s), order}..] can be used to clear a number of tensors of different orders.";



SetTensorValues::usage="SetTensorValues[Tensor[label, up, down], values, permissive:False] will set the component values of the tensor. The indices can be plain or flavored symbols. Existing values that have differently flavored indices are retained. The order of storage depends upon the sort order of the symbolic indices used in up and down. The values are stored in UpValues[label]. Setting tensor values deletes any corresponding tensor value rules. If permissive is True, size checking of arrays is skipped.";

SetTensorValues::dim="The number of indices cannot be greater than the number of dimensions of values.";

SetTensorValues::size="The size of each value array must be the same as NDim.";

SetTensorValueRules::usage="SetTensorValueRules[Tensor[label, up, down], values, permissive:False] will establish rules in TensorValueRules[label] for substituting the given values.  The indices can be plain or flavored symbols. Existing rules that have differently flavored indices are retained. The order of storage depends upon the sort order of the symbolic indices used in up and down. Setting tensor values rules deletes any corresponding tensor values. If permissive is True, size checking of arrays is skipped.";

SetTensorValueRules::dim="The number of indices cannot be greater than the number of dimensions of values.";

SetTensorValueRules::size="The size of each value array must be the same as NDim.";

TensorValueRules::usage="TensorValueRules[label] holds substitution value rules for Tensors with label.\nTensorValueRules[label1, label2,...] combines the substitution rules for several labels.";

ClearTensorValues::usage="ClearTensorValues[Tensor[label, upindices, downindices]] will clear the component values of the tensor as UpValues for label and also remove any corresponding substitution rules from TensorValueRules[label]. Existing definitions or rules that are different on the lhs are retained.";

NonzeroValueRules::usage="NonzeroValueRules[a, b, ...] will return the TensorValueRules for the labels a, b etc., which have nonzero right hand sides.";

SelectedTensorRules::usage="SelectedTensorRules[label, pattern] will select the rules for label whose right hand sides are nonzero and whose left hand sides match the pattern.";

DeclareZeroTensor::usage="DeclareZeroTensor[label] declares that a tensor of any type with the given label will have zero element values when expanded to an array.";



SetMetricValues::usage="SetMetricValues[g, metricmatrix, flavor:Identity] creates value definitions for the metric tensor and inverse of the metric tensor of label g from values of metricmatrix. The optional argument flavor specifies the flavor with which the definitions will be stored. The default value is Identity, which means no flavor. The metric matrix must also be in the desired flavor.\n
The definitions are stored in UpValues[g]";

SetMetricValueRules::usage="SetMetricValueRules[g, metricmatrix, flavor:Identity] creates a list of rules for the metric tensor and inverse of the metric tensor of label g from values of metricmatrix. The optional argument flavor specifies the flavor with which the rules will be stored. The default value is Identity, which means no flavor. The metric matrix must also be in the desired flavor.\n
To see, the created rules, evaluate: TensorValueRules[g]";

CalculateChristoffelu::usage="CalculateChristoffelu[xu[i], metricmatrix, simplification:Identity], calculates the array corresponding to the Christoffel symbols (\[CapitalGamma]udd[i,j,k]), from the values of metricmatrix and the x vector pattern.  The flavor is extracted from the flavor of i. Metricmatrix must also be in the desired flavor. simplification is an optional argument that supplies a simplification routine to be used on the Christoffel elements.";

CalculateChristoffeld::usage="CalculateChristoffelu[xu[i], metricmatrix, simplification:Identity], calculates the array corresponding to the Christoffel symbols (\[CapitalGamma]ddd[i,j,k]), from the values of metricmatrix and the x vector pattern.  The flavor is extracted from the flavor of i. Metricmatrix must also be in the desired flavor. simplification is an optional argument that supplies a simplification routine to be used on the Christoffel elements.";

SetChristoffelValueRules::usage=
  "SetChristoffelValueRules[xu[i], metricmatrix, \[CapitalGamma], simplification:Identity], creates a list of rules for the Christoffel symbols: \[CapitalGamma]udd[s, m, n] and \[CapitalGamma]ddd[s, m, n] from the values metricmatrix in coordinates of xu[i]. The flavor is extracted from the flavor of i. Metricmatrix must also be in the desired flavor. The rules are stored in TensorValueRules[\[CapitalGamma]] simplification is an optional argument that supplies a simplification routine to be used on the Christoffel elements."

SetChristoffelValues::usage=
  "SetChristoffelValueRules[xu[i], metricmatrix, \[CapitalGamma], simplification:Identity], creates a set of definitions for the Christoffel symbols: \[CapitalGamma]udd[s, m, n] and \[CapitalGamma]ddd[s, m, n] from the values metricmatrix in coordinates of xu[i]. The flavor is extracted from the flavor of i. Metricmatrix must also be in the desired flavor. The definitions are stored in UpValues[\[CapitalGamma]] simplification is an optional argument that supplies a simplification routine to be used on the Christoffel elements."



PartialD::usage="PartialD[tensor, i]  calculates the partial derivative of the tensor with respect to the coordinate of index i. \n PartialD[tensor, {i,j,...}] represents the covariant derivative with repect to the list of indicest\n An index with a comma as prefix represents the partial derivative over the respective index. \n
This is ambiguous until we expand the partial derivative providing the specific coordinates using ExpandPartialD. The derivative in this shape does can not calculate partial derivatives of components of tensors because the coordinates and the kronecker tensor are not yet specified. Symbols are considered constants when PartialD is used in this shape.\n
PartialD[{x,\[Delta],g,\[CapitalGamma]}][ tensor , Tensor[x,{i},{Void}] ] calculates the partial derivative respect to the i-coordinate using coordinate label x and kronecker tensor label \[Delta].\n
PartialD[{x,\[Delta],g,\[CapitalGamma]}][ tensor , {Tensor[x,{i},{Void}]..} ] calculates the higher order partial derivative over the coordinates. Symbols are not considered constants when the derivative is carried out over coordinates in this shape of the partial derivative (with labels)\n
PartialD[{x,\[Delta],g,\[CapitalGamma]}][ expr , v ] is the partial derivative of expr respect to the symbol v. When expr is free from tensor objects PartialD is reduced to the standard Mathematica partial derivative function D.\n
EvaluatePartialD is needed to fully evaluate the partial derivative, when the expression is completely expanded with the indices explicitly members of the global list BaseIndices. ";

ExpandPartialD::usage=
    "ExpandPartialD[{x,\[Delta],g,\[CapitalGamma]}][ expr ], expands the partial derivative involved in expr using coordinates label x and kronecker tensor \[Delta].";

NondependentPartialD::usage="NondependentPartialD[{lab1, lab2,...}..][expr] will implement the assumption that Tensor labels, {lab1, lab2,...} are nondependent so that a partial derivative of one with respect to another will be zero. Multiple lists of nondependent tensor labels may be provided";



CovariantD::usage="CovariantD[tensor, i] represents the covariant derivative of the tensor with respect to the index i.\nCovariantD[tensor, {i,j,...}] represents the covariant derivative with repect to the list of indices. \n Symbols are considered constans.";

ExpandCovariantD::usage="ExpandCovariantD[{x,\[Delta],g,\[CapitalGamma]},a][expr] will expand a covariant tensors using coordinates x, metric tensor g, Christoffel Symbol \[CapitalGamma] and the dummy index a.\n
ExpandCovariantD[{x,\[Delta],g,\[CapitalGamma]},{a,b,...}][expr] will expand covariant derivatives of higher order using {a,b,...} as dummy indices.\n
"



TotalD::usage="TotalD[ expr, t]  calculates the total derivative of expr with respect to the parameter t. Symbols are not considered constants unless they have the Constant attribute.\n 
TotalD[ expr, {t,v,...}] represents the covariant derivative with repect to the list of parameters \n 
This derivative can be we expanded in terms of its the partial derivative over the coordinates using ExpandTotalD.\n
TotalD is reduced to the standard Mathematica Dt if expr is free from tensor objects.
";

ExpandTotalD::usage=
  "ExpandTotalD[{x,\[Delta],g,\[CapitalGamma]},a][ tensor ], expands the total derivative with coordinates label x and kronecker tensor \[Delta] using the dummy index a\n
  
  ExpandTotalD[{x,\[Delta],g,\[CapitalGamma]},{a,b,...}][ tensor ], expands the total derivatives of higher order with coordinates label x and kronecker tensor \[Delta] using the dummy indices a, b, ..."

ExpandTotalD::dummies="Number of dummies `` does not match number of differentiation variables ``";



AbsoluteD::usage="AbsoluteD[tensor, t]  represents the absolute derivative of the tensor with respect to the parameter t. \nAbsoluteD[tensor, {t,v,...}] represents the absolute derivative with repect to the list of parameters \nThis derivative is ambiguous until we expand the partial derivative providing the specific coordinates using ExpandAbsoluteD."



ExpandAbsoluteD::usage=
  "ExpandAbsoluteD[{x,\[Delta],g,\[CapitalGamma]},{a,b}][expr] will expand a first order absolute derivative of tensors using coordinates x, Kronecker \[Delta], metric tensor g, Christoffel symbol \[CapitalGamma] and the dummy indices a and b.\nExpandAbsoluteD[{x,\[Delta],g,\[CapitalGamma]},{{a,b}, {c,d},...}][expr] will expand higher order absolute derivatives. \nTwo dummmy indices are needed for each order of expansion."



LieD::usage=
  "LieD[tensor, V]  represents the Lie derivative of the tensor with respect to the vector field V.\nLieD[tensor, {U,V...}] represents the Lie derivative with repect to the list of vector fields.\nThis derivative is ambiguous until we expand the partial derivatives, providing the specific coordinates using ExpandLieD."

ExpandLieD::usage=
  "ExpandLieD[{x,\[Delta],g,\[CapitalGamma]}, a][expr] will expand a first order Lie derivative of expr using coordinates x, Kronecker \[Delta] and dummy index a.\nExpandLieD[{x,\[Delta],g,\[CapitalGamma]}, {a,b,...}][expr] will expand higher order Lie derivatives using the list {a,b,..} as dummy indices."



FreeTensorQ::usage=
  "FreeTensorQ[ expr ], gives True or False if expr contains a Tensor "

FreeCovQ::usage=
  "FreeCovQ[ expr ], gives True or False if expr contains a covariant derivative "

FreeTotalDQ::usage=
  "FreeTotalDQ[ expr ], gives True or False if expr contains a total derivative "



Begin["`Private`"]



VoidString = " ";
$PrePrint=StyleForm[##,FontSize\[Rule]16,FontFamily\[Rule]"Courier"]&;



PVector=TCliffordAlgebra1`TClifford`PVector;



SetDerivativeSymbols[
    list:{_String,_String,_String,_String,_String,_String,_String}]:=
  Module[{},
    {DifSym,CovSym,TDu,TDd,ADu,ADd,LDSym}=list;
    If[LDSym==="",
      If[Length[FormatValues[LieD]]>0,Format[LieD[T_,V__]]=.],
      Format[LieD[T_,V__]]:=DisplayForm[RowBox[{LDSym,"[",T,",",V,"]"}]]]]



Format[ Tensor[A_] ]:= A;

Format[ Tensor[A_,up_List,down_List] ]:=
    Module[{newdown=down,newup=up,makespace},
      makespace=If[#1===Void,StyleForm[#2,ShowContents\[Rule]False],#1]&;
      newup=Inner[makespace,newup,newdown,List];
      newdown=Inner[makespace,newdown,newup,List];
      Subsuperscript[A,SequenceForm@@newdown,SequenceForm@@newup]
      ];



Unprotect[Power];
Format[Power[
        a_/;\[Not]FreeQ[{Head[a]},Tensor|PartialD|TotalD|AbsoluteD|HoldForm],
        power_],TraditionalForm]:=
    DisplayForm[
      SuperscriptBox[RowBox[{"(",ToBoxes[a,TraditionalForm],")"}],power]];
Format[Power[
        a_/;\[Not]FreeQ[{Head[a]},Tensor|PartialD|TotalD|AbsoluteD|HoldForm],
        power_]]:=
    DisplayForm[SuperscriptBox[RowBox[{"(",ToBoxes[a],")"}],power]];
Protect[Power];



Format[Dif[index_]]:=SequenceForm[DifSym,index]

Format[Cov[index_]]:=SequenceForm[CovSym,index]



Format[ PartialD[{x_,\[Delta]_,g_,\[CapitalGamma]_}][ w_ , Tx_List]  ] := 
    Module[{HF,dummy},
       Format[HF[p_,q__]]:=HoldForm[D[p,q]];
      HF[w,Sequence@@Tx]               
      ];

Format[ PartialD[{x_,\[Delta]_,g_,\[CapitalGamma]_}][ w_ ,Tx_   ]  ] :=
   Module[{},
      HoldForm[ D[w,Tx ] ]             
      ]/;Not[VectorQ[Tx]]



Format[TotalD[T_,t_]]:=
    Module[{st={t}},
        SequenceForm[TDu,
            T]/(SequenceForm@@MapThread[SequenceForm[TDd,#]&,{st}])
        ]/;Not[VectorQ[T]];

Format[TotalD[T_,{t__}]]:=
  Module[{n=Length[{t}],st=Sort[{t}]},
    SequenceForm[If[n\[Equal]1,TDu,Superscript[TDu,n]],
        T]/(SequenceForm@@MapThread[SequenceForm[TDd,#]&,{st}])
    ]

Format[TotalD[T_]]:=
  Module[{},
      DisplayForm[RowBox[{TDu,T}]]]/;Not[VectorQ[T]]



Format[AbsoluteD[T_,t_]]:=
    Module[{st={t}},
        SequenceForm[ADu,
            T]/(SequenceForm@@MapThread[SequenceForm[ADd,#]&,{st}])
        ]/;Not[VectorQ[T]];

Format[AbsoluteD[T_,{t__}]]:=
  Module[{n=Length[{t}],st=Sort[{t}]},
    SequenceForm[If[n\[Equal]1,ADu,Superscript[ADu,n]],
        T]/(SequenceForm@@MapThread[SequenceForm[ADd,#]&,{st}])
    ]



NestedTensor[expr_]:=Tensor[Tensor[expr],{},{}]

UnnestTensor[expr_]:=
  Module[{},
    expr/.{
        Tensor[Tensor[texpr_],ups_,downs:{Dif[_]..}]\[RuleDelayed]
          Module[{diffindices=Cases[downs,Dif[a_]\[Rule]a]},
            PartialD[texpr,diffindices]],
        Tensor[Tensor[texpr_],ups_,downs:{Cov[_]..}]\[RuleDelayed]
          Module[{diffindices=Cases[downs,Cov[a_]\[Rule]a]},
            CovariantD[texpr,diffindices]],
        
        PartialD[labs_][Tensor[Tensor[texpr_]],x_ ]\[RuleDelayed]
          PartialD[labs][texpr,x],
        
        HoldPattern[TotalD[Tensor[Tensor[texpr_],{},{}],s_]]\[RuleDelayed]
          TotalD[texpr,s],
        HoldPattern[AbsoluteD[Tensor[Tensor[texpr_],{},{}],s_]]\[RuleDelayed]
          AbsoluteD[texpr,s],
        Tensor[Tensor[texpr_],{},{}]\[Rule]texpr}]



ToArrayValues[][expr_]:=ToArrayValues[BaseIndices][expr]

ToArrayValues[baseindices_List][expr_]:=
  Module[{work,labels,valuerules,subroutine},
    subroutine[
        work_]:=(labels=
          Cases[work,Tensor[label_,___]\[Rule]label,{0,\[Infinity]}];
        valuerules=TensorValueRules@@labels;
        If[Head[valuerules]===List,work/.valuerules,work]);
    
    work=expr//EinsteinSum[baseindices]//EinsteinArray[baseindices];
    
    FixedPoint[subroutine,work,5]
    ]

ContractArray[tt_,inxs:({_,_}..)]:=Nest[Tr[#1,Plus,2]&,Transpose[tt,
      (* Calculate the destination slots of each level *)
      Block[{x=Range[TensorRank[tt]],cindices=Join[inxs]},
        x\[LeftDoubleBracket]Join[cindices,
              Complement[x,cindices]]\[RightDoubleBracket]=x;
        x]],
    Length[{inxs}]]



DeclareBaseIndices[
    indexlist:{(_Integer|_Symbol)..}]:= (BaseIndices=indexlist; 
    NDim=Length[BaseIndices];)

BaseIndexQ[index_]:=
  MemberQ[BaseIndices, RawIndex[index]]



LinearBreakout[f__][vars__][expr_]:=
  expr//.{(g:Alternatives@@{f})[p1___,a_+b__,p2___]\[RuleDelayed]
        g[p1,a,p2]+g[p1,Plus[b],p2],(g:Alternatives@@{f})[p1___,
          a_ b:Alternatives@@{vars},p2___]\[RuleDelayed]a g[p1,b,p2]}

PushOnto[argslist_List,ontolist_List][expr_]:=
  Module[{onto=Alternatives@@ontolist},
    expr/.(h_/;\[Not]FreeQ[h,onto])@@
          argslist\[RuleDelayed](h/.a_/;MatchQ[a,onto]\[Rule]a@@argslist)
    ]

PushOnto[ontolist_List][(head_)[arglist___]]:=
  Module[{onto=Alternatives@@ontolist},
    head/.a_/;MatchQ[a,onto]\[RuleDelayed]a[arglist]
    ]

CircleEvalRule=
  {CircleTimes[vects__][args__]/;Length[{vects}]==Length[{args}]\[RuleDelayed]
      Module[{scalar,tensor,a},
        scalar=
          Times@@Select[MapThread[Dot,{{vects},{args}}], FreeQ[#,Null]&];
        If[FreeQ[{args},Null],
          tensor=1,
          
          tensor=CircleTimes@@
              First@Transpose@
                  Select[Transpose[{{vects},{args}}],#\[LeftDoubleBracket]2\
\[RightDoubleBracket]==Null&];
          tensor=tensor/.CircleTimes[a_]\[Rule]a];
        scalar tensor],
    (v:Tensor[_,{_},{_}])[arg_]\[RuleDelayed]v.arg};

EvaluateSlots[b_Symbol,g_Symbol][expr_]:=
  Module[{bu,bd,work},
    {bu,bd}=Symbol[SymbolName[b]<>#]&/@{"u","d"};
    work=(expr/.head_?(\[Not]FreeQ[#,CircleTimes]&)[
                args___]\[RuleDelayed](ExpandAll[head[args]]//
                  PushOnto[{args},{CircleTimes[__]}])/.CircleEvalRule);
    work=(work//LinearBreakout[Dot][bu[_],bd[_]])/.BasisDotProductRules[b,g];
    work=work//MetricSimplify[g];
    work/.CircleTimes[x_]\[Rule]x
    ];

BasisDotProductRules[b_Symbol,
    g_Symbol]:={Tensor[b,{i_},{Void}].Tensor[b,{j_},{Void}]\[Rule]
      Tensor[g,{i,j},{Void,Void}],
    Tensor[b,{Void},{i_}].Tensor[b,{Void},{j_}]\[Rule]
      Tensor[g,{Void,Void},{i,j}],
    Tensor[b,{i_},{Void}].Tensor[b,{Void},{j_}]\[Rule]
      Tensor[g,{i,Void},{Void,j}],
    Tensor[b,{Void},{i_}].Tensor[b,{j_},{Void}]\[Rule]
      Tensor[g,{Void,j},{i,Void}]}

ReverseBasisDotProductRules[b_Symbol,
    g_Symbol]:={Tensor[g,{i_,j_},{Void,Void}]\[Rule]
      Tensor[b,{i},{Void}].Tensor[b,{j},{Void}],
    Tensor[g,{Void,Void},{i_,j_}]\[Rule]
      Tensor[b,{Void},{i}].Tensor[b,{Void},{j}],
    Tensor[g,{i_,Void},{Void,j_}]\[Rule]
      Tensor[b,{i},{Void}].Tensor[b,{Void},{j}],
    Tensor[g,{Void,j_},{i_,Void}]\[Rule]
      Tensor[b,{Void},{i}].Tensor[b,{j},{Void}]};

EvaluateDotProducts[e_,g_,metricsimplify_:True][expr_]:=
  expr/.
    {Dot[0,_]\[Rule]0,
      Dot[_,0]\[Rule]0,
      dp:Dot[_,_]\[RuleDelayed]((dp//
                  LinearBreakout[Dot][Tensor[e,{_},{Void}],
                    Tensor[e,{Void},{_}]])/.BasisDotProductRules[ e,g]//
            If[metricsimplify,MetricSimplify[g],Identity])}

ConstructDirectProduct[a_. b:CircleTimes[__]]:=
  Module[{work,heads,newhead,arglist},
    work=List@@b;
    heads=Head/@work;
    arglist=Replace[#,f_[args__]\[Rule]args]&/@work;
    newhead=CircleTimes@@heads;
    newhead=newhead//LinearBreakout[CircleTimes][CircleTimes[__]];
    newhead=newhead/.expr:CircleTimes[__]\[RuleDelayed]Flatten[expr];
    a (newhead@@arglist)]

GenerateBasisTensors[g_Symbol,configuration_String]:=
  Module[{configs,indices,basistensor},
    configs=Characters[configuration];
    If[\[Not]And@@((#==="d")\[Or](#==="u")&/@configs),
      Message[GenerateBasisTensors::config,configuration];Abort[]];
    indices=Table[Unique["i"],{Length[configs]}];
    basistensor=
      CircleTimes@@MapThread[Symbol[ToString[g]<>#1][#2]&,{configs,indices}];
    basistensor//ArrayExpansion[indices]//Flatten
    ]

UsePartialDChainRule[coordtensor_][expr_]:=
  expr/.HoldPattern[PartialD[labs_][x_Tensor,y_]]\[Rule]
      PartialD[labs][x,coordtensor]PartialD[labs][coordtensor,y]

UsePartialDChainRule[diffvar1_,diffvar2_][expr_]:=
  expr/.{HoldPattern[PartialD[labs_][x_Tensor,diffvar2]]\[Rule]
        PartialD[labs][x,diffvar1]PartialD[labs][diffvar1,diffvar2],
      HoldPattern[
          PartialD[labs_][x_Tensor,{varsa___,diffvar2,varsb___}]]\[Rule]
        PartialD[labs][x,{varsa,diffvar1,varsb}]PartialD[labs][diffvar1,
            diffvar2]}

UseTotalDChainRule[coordtensor_,labels_][expr_]:=
  expr/.HoldPattern[TotalD[x_,y_]]\[Rule]
      PartialD[labels][x,coordtensor]TotalD[coordtensor,y]





UnsortedUnion[x_]:=Module[{f},f[y_]:=(f[y]=Sequence[];y);f/@x]



ParseTermIndices[term_]:=
  Module[
    {wterms=term,slotsort,uplist,downlist,slotorder,badlist,dummylist,scalar,
      tlab},
    
    slotsort[list_]:=
      Sort[list,
        Part[Position[slotorder,#1],1,1]\[LessEqual]
            Part[Position[slotorder,#2],1,1]&];
    
    (* Convert the term to a list of tensors *)
    wterms=
      wterms/.a_Function\[RuleDelayed]If[Length[a]<3,Last[a],Part[a,2]]/.
                      (TotalD|AbsoluteD|LieD)[t_,___]\[Rule]t/.HoldPattern[
                        PartialD[_][t_,dvars_]]\[RuleDelayed]
                      t Times@@
                          Cases[dvars,
                            Tensor[l_,ups_,downs_]\[Rule]
                              Tensor[l,downs,ups],{0,1}]/.
                  
                  Tensor[Tensor[t_],ups_,downs_]\[RuleDelayed]
                    If[FreeQ[{t},Plus],t Tensor[tlab,ups,downs],scalar]/.
                
                Tensor[Tensor[t_]]\[RuleDelayed]
                  If[FreeQ[{t},Plus],t ,scalar]/.t_Tensor[___]\[Rule]t/.
            
            TGeneralRelativity1`GeneralRelativity`\[DoubleStruckD][
                t_]\[RuleDelayed]If[FreeQ[{t},Plus],t,scalar]/.
          (Dot|CircleTimes|TGeneralRelativity1`GeneralRelativity`Wedge)\[Rule]
            Times/.Tensor[_]\[Rule]1;
    wterms=If[Head[wterms]===Times,List@@wterms,{wterms}];
    wterms=
      Flatten[wterms/.Power[a_,n_Integer?Positive]\[RuleDelayed]
            Table[a,{n}]];
    wterms=If[Head[#]===Tensor,#,Unevaluated[Sequence[]]]&/@wterms;
    If[wterms==={},Return[{{},{{},{}},{}}]];
    
    (* Generate the indices in slotorder *)
    slotorder=(#/.Tensor[_,ups_,
                  downs_]\[RuleDelayed](Flatten@
                        Transpose[{ups,downs}]/.Void\[Rule]
                        Sequence[]/.(Cov|Dif)\[Rule]Identity))&/@wterms;
    slotorder=UnsortedUnion@Join@@slotorder;
    
    (* Extract the up and down indices *)
    uplist=
      Flatten@(wterms/.Tensor[_,ups_,_]\[Rule]ups)/.Void\[Rule]
            Sequence[]/.(Cov|Dif)\[Rule]Identity;
    uplist=(If[BaseIndexQ[#],Unevaluated[Sequence[]],#]&/@uplist);
    downlist=
      Flatten@(wterms/.Tensor[_,_,downs_]\[Rule]downs)/.Void\[Rule]
            Sequence[]/.(Cov|Dif)\[Rule]Identity;
    downlist=(If[BaseIndexQ[#],Unevaluated[Sequence[]],#]&/@downlist);
    
    (* Extract the bad indicies. 
          They occur more than once in the uplist or in the downlist *)
    badlist=
      Union@Flatten@{Cases[Split[Sort@uplist],t_List/;Length[t]>1],
            Cases[Split[Sort@downlist],t_List/;Length[t]>1]};
    
    (* Remove bad indices from uplist and downlist *)
    uplist=uplist/.Alternatives@@badlist\[Rule]Sequence[];
    downlist=downlist/.Alternatives@@badlist\[Rule]Sequence[];
    
    (* Extract the dummy indices and remove them from uplist and downlist*)
    dummylist =Intersection[uplist,downlist];
    uplist=uplist/.Alternatives@@dummylist\[Rule]Sequence[];
    downlist=downlist/.Alternatives@@dummylist\[Rule]Sequence[];
    
    {slotsort@dummylist,slotsort/@{uplist,downlist},badlist}
    ]

RawIndex[index_]:=
  Switch[index,
    Cov[_]|Dif[_],RawIndex[First[index]],
    (f_?IndexFlavorQ)[_],First[index],
    _Symbol|_Integer,index,
    _,Message[RawIndex::notindex,index];index]

ExtractFreeIndices[expr_]:=
  Module[{terms,updowns,matched,badindices,nobadindices},
    terms=Flatten[{Expand[expr]/.Equal\[Rule]List/.Plus\[Rule]List}];
    terms=ParseTermIndices/@terms;
    terms=Transpose[terms];
    badindices=Take[terms,-1];
    terms=Part[terms,2];
    terms=MapAt[Sort,#,{{1},{2}}]&/@terms;
    updowns=First[terms];
    nobadindices=Length[Flatten[badindices]]\[Equal]0;
    matched=And@@(updowns===#&/@terms);
    If[nobadindices\[And]matched,updowns,Message[FreeIndices::notmatched];
      False]
    ]

SymbolicIndexQ[i_]:=
  Module[{ISymbol},
    ISymbol[s_]:=Head[s]===Symbol\[And]\[Not]BaseIndexQ[s];
    MatchQ[i,( _?ISymbol)|((_?IndexFlavorQ)[_?ISymbol])]
    ]



\!\(jval[i_, j_, array_, pos_] := \[IndentingNewLine]Module[{jnew, newpos}, \[IndentingNewLine]newpos = First[pos]; \[IndentingNewLine]jnew = If[Length[newpos] \[Equal] 1, j, array\_\(\(\[LeftDoubleBracket]\)\(First[newpos]\)\(\[RightDoubleBracket]\)\) /. i \[Rule] j]; \[IndentingNewLine]{jnew, First[newpos]}]\)

RaiseIndex[i_,j_][expr_/;Head[expr]=!=Tensor]:=
  expr/.t:Tensor[_,_,downs_/;\[Not]FreeQ[downs,i]]\[RuleDelayed]
      RaiseIndex[i,j][t]

\!\(\(RaiseIndex[i_, j_]\)[t_Tensor] := \[IndentingNewLine]Module[{pos, ups, downs, jnew}, \[IndentingNewLine]{ups, downs} = List @@ t\_\(\(\[LeftDoubleBracket]\)\({2, 3}\)\(\[RightDoubleBracket]\)\); \[IndentingNewLine]pos = Position[downs, i]; \[IndentingNewLine]If[pos === {}, Message[RaiseIndex::noindex, i, t]; Abort[]]; \[IndentingNewLine]{jnew, pos} = jval[i, j, downs, pos]; \[IndentingNewLine]downs\_\(\(\[LeftDoubleBracket]\)\(pos\)\(\[RightDoubleBracket]\)\) = Void; \[IndentingNewLine]ups\_\(\(\[LeftDoubleBracket]\)\(pos\)\(\[RightDoubleBracket]\)\) = jnew; \[IndentingNewLine]Tensor[First[t], ups, downs]\[IndentingNewLine]]\)

LowerIndex[i_,j_][expr_/;Head[expr]=!=Tensor]:=
  expr/.t:Tensor[_,ups_/;\[Not]FreeQ[ups,i],_]\[RuleDelayed]LowerIndex[i,j][t]

\!\(\(LowerIndex[i_, j_]\)[t_Tensor] := \[IndentingNewLine]Module[{pos, ups, downs, jnew}, \[IndentingNewLine]{ups, downs} = List @@ t\_\(\(\[LeftDoubleBracket]\)\({2, 3}\)\(\[RightDoubleBracket]\)\); \[IndentingNewLine]pos = Position[ups, i]; \[IndentingNewLine]If[pos === {}, Message[LowerIndex::noindex, i, t]; Abort[]]; \[IndentingNewLine]{jnew, pos} = jval[i, j, ups, pos]; \[IndentingNewLine]ups\_\(\(\[LeftDoubleBracket]\)\(pos\)\(\[RightDoubleBracket]\)\) = Void; \[IndentingNewLine]downs\_\(\(\[LeftDoubleBracket]\)\(pos\)\(\[RightDoubleBracket]\)\) = jnew; \[IndentingNewLine]Tensor[First[t], ups, downs]\[IndentingNewLine]]\)



ReplaceIndex[i_,j_][expr_/;Head[expr]=!=Tensor]:=
  expr/.t:Tensor[_,ups_,downs_]/;\[Not]FreeQ[Union[ups,downs],i]\[RuleDelayed]
      ReplaceIndex[i,j][t]

\!\(\(ReplaceIndex[i_, j_]\)[t_Tensor] := \[IndentingNewLine]Module[{ups, downs, posups, posdowns, jnew}, \[IndentingNewLine]{ups, downs} = List @@ t\_\(\(\[LeftDoubleBracket]\)\({2, 3}\)\(\[RightDoubleBracket]\)\); \[IndentingNewLine]posups = Position[ups, i]; \[IndentingNewLine]posdowns = Position[downs, i]; \[IndentingNewLine]If[posups === {} \[And] posdowns === {}, Message[ReplaceIndex::noindex, i, t]; Abort[]]; \[IndentingNewLine]If[posups =!= {}, {jnew, pos} = jval[i, j, ups, posups]; \[IndentingNewLine]ups\_\(\(\[LeftDoubleBracket]\)\(pos\)\(\[RightDoubleBracket]\)\) = jnew;]; \[IndentingNewLine]If[posdowns =!= {}, {jnew, pos} = jval[i, j, downs, posdowns]; \[IndentingNewLine]downs\_\(\(\[LeftDoubleBracket]\)\(pos\)\(\[RightDoubleBracket]\)\) = jnew;]; \[IndentingNewLine]Tensor[First[t], ups, downs]\[IndentingNewLine]]\)



IndexChange[pair:{_?SymbolicIndexQ,_?SymbolicIndexQ},sign_:1][expr_]:=
  Module[{target=First[pair],new=Last[pair],
      dropdif={Cov\[Rule]Identity,Dif\[Rule]Identity},replcfunc,termindices},
    replcfunc=If[MatchQ[#/.dropdif,target],#/.target\[Rule]new,#]&;
     expr/.term:(_Times|_Dot|_CircleTimes|PartialD[_][__]|
                Tensor[_,_,_])/;(\[Not]FreeQ[term,Tensor])\[And](termindices=
                Flatten[Part[ParseTermIndices[term],{1,2}]]/.dropdif;
              MemberQ[termindices,target])\[RuleDelayed]
        Module[{fakeFunction,wterm},
          wterm=term//.Function\[Rule]fakeFunction;
          
          wterm=sign(wterm/.Tensor[label_,ups_,downs_]/;
                      MemberQ[ups/.dropdif,target]\[Or]
                        MemberQ[downs/.dropdif,target]\[RuleDelayed]
                    Tensor[label,replcfunc/@ups,replcfunc/@downs]);
          wterm//.fakeFunction\[Rule]Function]]

\!\(\(IndexChange[pairs : {{_, _} .. }, sign_:  1]\)[expr_] := \[IndentingNewLine]Module[{targets = First /@ pairs, news = Last /@ pairs, termindices, dropdif = {Cov \[Rule] Identity, Dif \[Rule] Identity}, replcfunc, target, new, pos}, \[IndentingNewLine]replcfunc = If[MemberQ[{target = # /. dropdif}, Alternatives @@ targets], pos = \(Position[targets, target]\)\_\(\(\[LeftDoubleBracket]\)\(1, 1\)\(\[RightDoubleBracket]\)\); new = Part[news, pos]; # /. target \[Rule] new, #] &; \[IndentingNewLine]expr /. term : \((_Times | _Dot | _CircleTimes | \(PartialD[_]\)[__] | Tensor[_, _, _])\) /; \((\[Not] FreeQ[term, Tensor])\) \[And] \((termindices = Flatten[Part[ParseTermIndices[term], {1, 2}]] /. dropdif; And @@ \((\(MemberQ[termindices, #] &\) /@ targets)\))\) \[RuleDelayed] Module[{fakeFunction, wterm}, \[IndentingNewLine]wterm = term //. Function \[Rule] fakeFunction; \[IndentingNewLine]wterm = sign\ \((wterm /. Tensor[label_, ups_, downs_] /; MemberQ[ups /. dropdif, Alternatives @@ targets] \[Or] MemberQ[downs /. dropdif, Alternatives @@ targets] \[RuleDelayed] Tensor[label, replcfunc /@ ups, replcfunc /@ downs])\); \[IndentingNewLine]wterm //. fakeFunction \[Rule] Function]]\)





\!\(tensorindexpositions[expr_, indx_] := \[IndentingNewLine]Module[{a, p, pos1, pos2, ppos1, ppos2, work}, \[IndentingNewLine]pos1 = Position[expr, Tensor[_, a__] /; \[Not] FreeQ[{a}, indx]]; \[IndentingNewLine]ppos1 = \(p @@ # &\) /@ pos1; \[IndentingNewLine]pos2 = Position[expr, indx]; \[IndentingNewLine]ppos2 = \(p @@ # &\) /@ pos2; \[IndentingNewLine]work = Outer[{#1, #2} &, ppos1, ppos2] /. p \[Rule] List; \[IndentingNewLine]work = Flatten[work, 1]; \[IndentingNewLine]Select[work, #\_\(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\) === Take[#\_\(\(\[LeftDoubleBracket]\)\(2\)\(\[RightDoubleBracket]\)\), Length[#\_\(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\)]] &]\[IndentingNewLine]]\)



UpDownSwap[indx_][expr_]:=
  Module[{q1=Unique[q],q2=Unique[q],pos,wexpr,swap},
    
    swap[i_,pos_,j_][wexpr_]:=
      Module[{updown},
        updown=Part[Last[pos],Length[First[pos]]+1];
        Switch[updown,
          2,LowerIndex[i,j][Part[wexpr,Sequence@@First[pos]]],
          3,RaiseIndex[i,j][Part[wexpr,Sequence@@First[pos]]]]
        ];
    
    Switch[Head[expr],
      List,UpDownSwap[indx]/@expr,
      Equal|Less|Greater|LessEqual|GreaterEqual,UpDownSwap[indx]/@expr,
      Plus,UpDownSwap[indx]/@expr,
      _,
      If[\[Not]MemberQ[First[ParseTermIndices[expr]], indx],Return[expr]];
      wexpr=Hold@@{expr};
      pos=tensorindexpositions[wexpr,indx];
      wexpr=ReplacePart[wexpr,q1,Last[First[pos]]];
      wexpr=ReplacePart[wexpr,q2,Last[Last[pos]]];
      
      wexpr=
        ReplacePart[wexpr,swap[q1,First[pos],indx][wexpr],First[First[pos]]];
      wexpr=
        ReplacePart[wexpr,swap[q2,Last[pos],indx][wexpr],First[Last[pos]]];
      First[wexpr]
      ]
    ]



DoubleVoidRule = 
  Tensor[P_,{subP__},{supP1___,Void,supP2___}] -> 
    Tensor[P,{subP},{supP1,fXX[Void],supP2}] ;

DoubleIndexSimplifyRule01=	
a_.*Tensor[A_,{subA__},{supA1___,i_,supA2___}]*
        Tensor[B_,{subB1___,i_,subB2___},{supB___}] +
b_.*Tensor[A_,{subAA__},{supAA1___,j_,supAA2___}]*
        Tensor[B_,{subBB1___,j_,subBB2___},{supBB___}] :> 
a*Tensor[A,{subA},{supA1,i,supA2}]  Tensor[B,{subB1,i,subB2},{supB}]+
b*Tensor[A,{subAA},{supAA1,fXX[i],supAA2} ]*
          Tensor[B,{subBB1,i,subBB2},{supBB}] /;
      FreeQ[{supAA1,supAA2,subBB1,subBB2},i]

DoubleIndexSimplifyRule02 =
a_.*Tensor[ A_,{subA1___,i_,subA2___},{supA1___,i_,supA2___}] + 
b_.*Tensor[ A_,{subAA1___,k_,subAA2___},{supAA1___,k_,supAA2___}]	:>
a*Tensor[ A,{subA1,i,subA2},{supA1,i,supA2}]+ 
b*Tensor[ A,{subAA1,fXX[i],subAA2},{supAA1,i,supAA2}]/;
      Length[{subA2}]===Length[{subAA2}];

DoubleIndexSimplifyRule03=	
a_. Tensor[A_,{subA__},{supA1___,i_,supA2___}]*
        Tensor[B_,{subB1___,i_,subB2___},{supB___}]+
b_. Tensor[A_,{subAA__},{supAA1___,j_,supAA2___}]*
        Tensor[B_,{subBB1___,j_,subBB2___},{supBB___}]* 
Tensor[P_,{subP__},{supP1___,i_,supP2___}]*
        Tensor[Q_,{subQ1___,i_,subQ2___},{supQ___}] :> 
a*Tensor[A,{subA},{supA1,i,supA2}]  Tensor[B,{subB1,i,subB2},{supB}] +
b*Tensor[A,{subAA},{supAA1,fXX[i],supAA2} ]*
        Tensor[B,{subBB1,i,subBB2},{supBB}]*
        Tensor[P,{subP},{supP1,j,supP2}]*  
Tensor[Q,{subQ1,j,subQ2},{supQ}] ;

DoubleIndexSimplifyRule04 =
a_.*Tensor[ A_,{subA1___,i_,subA2___},{supA1___,i_,supA2___}]+ 
b_.* Tensor[ A_,{subAA1___,k_,subAA2___},{supAA1___,k_,supAA2___}]*
        Tensor[P_,{subP__},{supP1___,i_,supP2___}]*  
Tensor[Q_,{subQ1___,i_,subQ2___},{supQ___}]  :> 
    a*Tensor[ A,{subA1,i,subA2},{supA1,i,supA2}]+ 
b*Tensor[ A,{subAA1,fXX[i],subAA2},{supAA1,i,supAA2}]* 
          Tensor[P,{subP},{supP1,k ,supP2}]*  
Tensor[Q,{subQ1,k,subQ2},{supQ}]/;Length[{subA2}]===Length[{subAA2}];	

DoubleIndexSimplifyRule05 =	{
a_.*Tensor[A_,{subA1___,i_,subA2___,j_,subA3___},{supA__}]*
Tensor[B_,{subB__},{supB1___,i_,supB2___}]*
Tensor[C_,{subC__},{supC1___,j_,supC2___}]  +
b_.*Tensor[A_,{subAA1___,j_,subAA2___,i_,subAA3___},{supA__}]*
Tensor[B_,{subB__},{supBB1___,i_,supBB2___}]*
Tensor[C_,{subC__},{supCC1___,j_,supCC2___}]:>
a*Tensor[A,{subA1,i,subA2,j,subA3},{supA}]*
Tensor[B,{subB},{supB1,i,supB2}]*Tensor[C,{subC},{supC1,j,supC2}]  +
b*Tensor[A,{subAA1,i,subAA2,j,subAA3},{supA}]*
Tensor[B,{subB},{supBB1,j,supBB2}]*Tensor[C,{subC},{supCC1,i,supCC2}]
,
a_.*Tensor[A_,{subA__},{supA1___,i_,supA2___,j_,supA3___}]*
Tensor[B_,{subB1___,i_,subB2___},{supB__}]*
Tensor[C_,{subC1___,j_,subC2___},{supC__}]  +
b_.*Tensor[A_,{subA__},{supAA1___,j_,supAA2___,i_,supAA3___}]*
Tensor[B_,{subBB1___,i_,subBB2___},{supB__}]*
Tensor[C_,{subCC1___,j_,subCC2___},{supC__}]   :>
a*Tensor[A,{subA},{supA1,i,supA2,j,supA3}]*
Tensor[B,{subB1,i,subB2},{supB}]*
Tensor[C,{subC1,j,subC2},{supC}]  +
b*Tensor[A,{subA},{supAA1,i,supAA2,j,supAA3}]*
Tensor[B,{subBB1,j,subBB2},{supB}]*
Tensor[C,{subCC1,i,subCC2},{supC}]
};
        

DummySimplify[w_]:=Module[{},
Expand[w]//.DoubleVoidRule//.DoubleIndexSimplifyRule04//.
DoubleIndexSimplifyRule02//.DoubleIndexSimplifyRule03//.\
DoubleIndexSimplifyRule01/.fXX[xx_]\[Rule]xx]//.DoubleIndexSimplifyRule05;



SimplifyTensorSum[sum_]/;MemberQ[(Times|Plus),Head[sum]]:=
  Module[{wsum,termindices,dummies,containsbadterms,i,termdummies,rule},
    wsum=Expand[sum];
    wsum=If[Head[wsum]===Plus,List@@wsum,{wsum}];
    termindices=ParseTermIndices/@wsum;
    containsbadterms=False;
    Do[If[termindices\[LeftDoubleBracket]i,3\[RightDoubleBracket]=!={},
        containsbadterms=True;
        Message[SimplifyTensorSum::badterm,
          wsum\[LeftDoubleBracket]i\[RightDoubleBracket]]],{i,1,
        Length[wsum]}];
    If[containsbadterms,Abort[]];
    If[\[Not](SameQ@@
            Table[Sort/@
                termindices\[LeftDoubleBracket]i,2\[RightDoubleBracket],{i,1,
                Length[wsum]}]),Message[SimplifyTensorSum::free];Abort[]];
    dummies=
      UnsortedUnion[
        Join@@Table[
            termindices\[LeftDoubleBracket]i,1\[RightDoubleBracket],{i,1,
              Length[wsum]}]];
    Do[termdummies=termindices\[LeftDoubleBracket]i,1\[RightDoubleBracket];
      rule=Thread[termdummies\[Rule]Take[dummies,Length[termdummies]]];
      wsum\[LeftDoubleBracket]i\[RightDoubleBracket]=
        wsum\[LeftDoubleBracket]i\[RightDoubleBracket]/.rule,{i,1,
        Length[wsum]}];
    Plus@@wsum
    ]

SimplifyTensorSum[expr_?(FreeQ[#,Tensor]&)]:=expr



PatternReplaceIndex[newindices:{_,___},patt_,checkdummies_:True][expr_Plus]:=
  PatternReplaceIndex[newindices,patt,checkdummies]/@expr

PatternReplaceIndex[newindices:{_,___},patt_,checkdummies_:True][expr_]:=
  Module[{workpatt,workexpr,newflavors,patternindices,flavor,newworkindices,
      targetexpression,restpattern,p,t,prules,patternindices2,targetindices,
      tindices,hit},
    
    workpatt=patt/.Pattern\[Rule]p;
    newworkindices=Sort[newindices,OrderedQ[{RawIndex[#1],RawIndex[#2]}]&];
    newflavors=GetIndexFlavor/@newworkindices;
    patternindices=Cases[workpatt,p[i_,Blank[]],\[Infinity]]//Union;
    patternindices2=
      patternindices/.{flavor[p[i_],_]\[Rule]flavor[i],p[i_,_]\[Rule]i};
    
    If[Length[patternindices]\[NotEqual]Length[newindices],
      Message[PatternReplaceIndex::numindices,patt];Abort[]];
    
    prules=Thread[patternindices\[Rule]newworkindices];
    targetexpression=workpatt/.prules;
    targetindices=Flatten[Take[ParseTermIndices[targetexpression],2]];
    
    If[checkdummies\[And]
        Sort[First[ParseTermIndices[targetexpression]]]=!=Sort[newindices],
      Message[PatternReplaceIndex::dummies,patt];Abort[]];
     
    hit=False;
    workexpr=expr/.Pattern[Evaluate[t],restpattern_.patt]\[RuleDelayed]
          Module[{commonindices,targindices},
            tindices=Flatten[Take[ParseTermIndices[t/restpattern],2]];
            commonindices=Intersection[tindices,targetindices];
            tindices=Complement[tindices,commonindices ];
            targindices=Complement[targetindices,commonindices ];
            
            If[(GetIndexFlavor/@tindices)===(GetIndexFlavor/@targindices),
              hit=True;restpattern targetexpression,t]
            ];
    If[checkdummies\[Or]\[Not]hit,workexpr,
      workexpr//IndexChange[Transpose[{tindices,newworkindices}]]]
    ]



MapLevelParts[func_,
      part:{toppart___Integer?Positive,
          subp:{_Integer?Positive,eprest__Integer?Positive}}][expr_]:=
  Module[{work,subparts,npos,null,i,nnull=Length[{eprest}],tempfunc},
    work=tempfunc@Part[expr,Sequence@@part];
    subparts=Thread[{toppart,subp}];
    newparts={work,Table[null[i],{i,1,nnull}]}//Flatten;
    npos=Partition[Range[nnull+1],1];
    work=ReplacePart[expr,newparts,subparts,npos]/.null[_]\[Rule]Sequence[];
    work/.tempfunc\[Rule]func
    ]



MapLevelPatterns[func_,{toppart___Integer?Positive,{pattern_}}][expr_]:=
  Module[{work,levelpos},
    work=Part[expr,toppart];
    levelpos=Flatten@Position[work,pattern,{1}];
    If[Length[levelpos]\[Equal]0,
      Message[MapLevelPatterns::nomatch,pattern,work];expr,
      expr//MapLevelParts[func,{toppart,levelpos}]]]



SumExpansion[indices:(_Symbol|(f_?IndexFlavorQ)[_Symbol])..][expr_]:=
  SumExpansion[{indices},BaseIndices][expr]

SumExpansion[indices:(_Symbol|(f_?IndexFlavorQ)[_Symbol])..,baseindices_List][
    expr_]:=SumExpansion[{indices},baseindices][expr]



SumExpansion[indices_List,baseindices_:BaseIndices][inexpr_]:=
  Module[{expr=ExpandAll[inexpr],idx,windices,inindex,replace,nbases,uq,q,
      uqreplace},
    
    If[\[Not](Intersection[baseindices,BaseIndices]===Sort[baseindices]),
      Message[SumArrayExpansion::subset,baseindices,BaseIndices];Abort[]];
    nbases=Length[baseindices];
    
    inindex[i_]:=(Count[{expr},
              Tensor[_,up_/;\[Not]FreeQ[up, i|Dif[i]|Cov[i],1],down_]|
                Tensor[_,up_,down_/;\[Not]FreeQ[down,  i|Dif[i]|Cov[i],1]]|
                PartialD[_][_,i]|
                PartialD[_,i],\[Infinity],Heads\[Rule]True]>
            0\[And]\[Not]MemberQ[BaseIndices,RawIndex[i]]);
    
    replace[i_,idx_]:=
      Switch[Head[i],_?IndexFlavorQ,
        Head[i][baseindices\[LeftDoubleBracket]idx\[RightDoubleBracket]],_,
        baseindices\[LeftDoubleBracket]idx\[RightDoubleBracket]];
    
    uqreplace[i_]:=
      Switch[Head[i],
        _?IndexFlavorQ,Head[i][q],
        _,q];
    
    Switch[Head[expr],
      List,SumExpansion[indices,baseindices]/@expr,
      Equal,SumExpansion[indices,baseindices]/@expr,
      Power,SumExpansion[indices,baseindices]/@expr,
      Plus,SumExpansion[indices,baseindices]/@expr,
      _,windices=Select[indices,inindex[#]&];
      Fold[
        Plus@@Table[(#1//IndexChange[{#2,uq=uqreplace[#2]}])/.uq\[Rule]
                  replace[#2,idx],{idx,1,nbases}]&,expr,windices]]
    ]



ArrayExpansion[indices:(_Symbol|(f_?IndexFlavorQ)[_Symbol])..][expr_]:=
  ArrayExpansion[{indices},BaseIndices][expr]

ArrayExpansion[indices:(_Symbol|(f_?IndexFlavorQ)[_Symbol])..,
      baseindices_List][expr_]:=ArrayExpansion[{indices},baseindices][expr]



ArrayExpansion[indices_List,baseindices_:BaseIndices][expr_]:=
  Module[{idx,windices,inindex,replace,nbases,uq,q,uqreplace},
    
    If[\[Not](Intersection[baseindices,BaseIndices]===Sort[baseindices]),
      Message[SumArrayExpansion::subset,baseindices,BaseIndices];Abort[]];
    nbases=Length[baseindices];
    
    inindex[i_]:=(Count[{expr},
              Tensor[_,up_/;\[Not]FreeQ[up, i|Dif[i]|Cov[i],1],down_]|
                Tensor[_,up_,down_/;\[Not]FreeQ[down,  i|Dif[i]|Cov[i],1]]|
                Tensor[_,up_/;\[Not]FreeQ[up, i|Dif[i]|Cov[i],1],down_][_]|
                
                Tensor[_,up_,
                    down_/;\[Not]FreeQ[down,  i|Dif[i]|Cov[i],1]][_]|
                PartialD[_][_,i]|
                PartialD[_,i],\[Infinity],Heads\[Rule]True]>
            0\[And]\[Not]MemberQ[BaseIndices,RawIndex[i]]);
    
    replace[i_,idx_]:=
      Switch[Head[i],
        _?IndexFlavorQ,
        Head[i][baseindices\[LeftDoubleBracket]idx\[RightDoubleBracket]],
        _,baseindices\[LeftDoubleBracket]idx\[RightDoubleBracket]];
    
    uqreplace[i_]:=
      Switch[Head[i],
        _?IndexFlavorQ,Head[i][q],
        _,q];
    
    windices=Select[indices,inindex[#]&];
    
    Fold[List@@
          Table[(#1//IndexChange[{#2,uq=uqreplace[#2]}])/.uq\[Rule]
                replace[#2,idx],{idx,1,nbases}]&,expr,Reverse[windices]]
    ]



EinsteinSum[][expr_]:=EinsteinSum[BaseIndices][expr]

EinsteinSum[baseindices_List][inexpr_]:=
  Module[{sumindices,expr=ExpandAll[inexpr]},
    Switch[Head[expr],
      List,EinsteinSum[baseindices]/@expr,
      Equal,EinsteinSum[baseindices]/@expr,
      Power,EinsteinSum[baseindices]/@expr,
      Plus,EinsteinSum[baseindices]/@expr,
      _, 
      sumindices=First[ParseTermIndices[expr]];
      If[Length[sumindices]\[Equal]0,Return[expr]];
      SumExpansion[sumindices, baseindices][expr]]
    ]



EinsteinArray[][expr_]:=EinsteinArray[BaseIndices][expr]

EinsteinArray[baseindices_][expr_]:=
  Module[{freeindices},
    freeindices=ExtractFreeIndices[expr];
    If[freeindices===False,Abort[]];
    If[Length[freeindices]==0,Return[expr]];
    freeindices=
      Sort[Flatten[freeindices],OrderedQ[{RawIndex[#1],RawIndex[#2]}]&];
    ArrayExpansion[freeindices, baseindices][expr]
    ]



\!\(\(PartialSum[baseindex_, newindices_List]\)[expr_] := \[IndentingNewLine]Module[{baseexpand, freeindices, dummyindices, numdummy, array, newwork}, \[IndentingNewLine]\[IndentingNewLine]baseexpand[term_] := \[IndentingNewLine]Module[{iarray = 1, gen, flavors}, \[IndentingNewLine]flavors = \(If[IndexFlavorQ[Head[#]], Head[#], Identity] &\) /@ dummyindices; \[IndentingNewLine]\[IndentingNewLine]gen[idepth_, indices_] := \[IndentingNewLine]Module[{}, \[IndentingNewLine]If[idepth > numdummy, \[IndentingNewLine]array = ReplacePart[array, indices, \(iarray++\)], \[IndentingNewLine]gen[idepth + 1, indices]; \[IndentingNewLine]gen[idepth + 1, ReplacePart[indices, flavors\_\(\(\[LeftDoubleBracket]\)\(idepth\)\(\[RightDoubleBracket]\)\)@baseindex, idepth]]]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]gen[1, dummyindices]; \[IndentingNewLine]Plus @@ \((term /. Thread /@ MapThread[dummyindices \[Rule] # &, {array}])\)\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]Switch[Head[expr], \[IndentingNewLine]List, PartialSum[baseindex, newindices] /@ expr, \[IndentingNewLine]Equal, PartialSum[baseindex, newindices] /@ expr, \[IndentingNewLine]Plus, PartialSum[baseindex, newindices] /@ expr, \[IndentingNewLine]_, \[IndentingNewLine]If[\[Not] MemberQ[BaseIndices, baseindex], Message[PartialSum::baseindex, baseindex, BaseIndices]; Abort[]]; \[IndentingNewLine]{dummyindices, freeindices} = \({Part[#, 1], Flatten[Part[#, 2]]} &\)[ParseTermIndices[expr]]; \[IndentingNewLine]newwork = Complement[newindices, freeindices]; \[IndentingNewLine]numdummy = Length[dummyindices]; \[IndentingNewLine]If[Length[newwork] < numdummy, Message[PartialSum::newindices, newwork, freeindices, dummyindices]; Abort[]]; \[IndentingNewLine]array = Table[{0, 0}, {2\^numdummy}]; \[IndentingNewLine]baseexpand[expr] /. Thread[dummyindices \[Rule] Take[newwork, Length[dummyindices]]]]\[IndentingNewLine]]\)



\!\(\(PartialArray[baseindex_, newindices_List]\)[expr_] := \[IndentingNewLine]Module[{baseexpand, freeindices, dummyindices, numfree, array, newwork}, \[IndentingNewLine]\[IndentingNewLine]baseexpand[term_] := \[IndentingNewLine]Module[{iarray = 1, gen, flavors}, \[IndentingNewLine]\[IndentingNewLine]flavors = \(If[IndexFlavorQ[Head[#]], Head[#], Identity] &\) /@ freeindices; \n\[IndentingNewLine]gen[idepth_, indices_] := \[IndentingNewLine]Module[{}, \[IndentingNewLine]If[idepth > numfree, \[IndentingNewLine]array = ReplacePart[array, indices, \(iarray++\)], \[IndentingNewLine]gen[idepth + 1, indices]; \[IndentingNewLine]gen[idepth + 1, ReplacePart[indices, flavors\_\(\(\[LeftDoubleBracket]\)\(idepth\)\(\[RightDoubleBracket]\)\)@baseindex, idepth]]]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]gen[1, freeindices]; \[IndentingNewLine]\((term /. Thread /@ MapThread[freeindices \[Rule] # &, {array}])\) // Reverse\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]If[ExtractFreeIndices[expr] === False, Abort[]]; \[IndentingNewLine]\[IndentingNewLine]Switch[Head[expr], \[IndentingNewLine]List, PartialArray[baseindex, newindices] /@ expr, \[IndentingNewLine]Equal, PartialArray[baseindex, newindices] /@ expr, \[IndentingNewLine]Plus, PartialArray[baseindex, newindices] /@ expr, \[IndentingNewLine]_, \[IndentingNewLine]If[\[Not] MemberQ[BaseIndices, baseindex], Message[PartialArray::baseindex, baseindex, BaseIndices]; Abort[]]; \[IndentingNewLine]{dummyindices, freeindices} = \({Part[#, 1], Flatten[Part[#, 2]]} &\)[ParseTermIndices[expr]]; \[IndentingNewLine]newwork = Complement[newindices, dummyindices]; \[IndentingNewLine]numfree = Length[freeindices]; \[IndentingNewLine]If[Length[newwork] < numfree, Message[PartialArray::newindices, newwork, dummyindices, freeindices]; Abort[]]; \[IndentingNewLine]array = Table[{0, 0}, {2\^numfree}]; \[IndentingNewLine]baseexpand[expr] /. Thread[freeindices \[Rule] Take[newwork, numfree]]]\[IndentingNewLine]]\)



EinsteinArgument[x_,func_:Automatic][expr_]:=
  Switch[func,
    Automatic,
    expr/.{(f_)[Tensor[x,{a_},{Void}]]\[RuleDelayed]
          f@@EinsteinArray[][Tensor[x,{a},{Void}]],
        (f_)[Tensor[x,{a_},{Void}][args___]]\[RuleDelayed]
          f@@EinsteinArray[][Tensor[x,{a},{Void}][args]]},
    _,expr/.{(f:func)[Tensor[x,{a_},{Void}]]\[RuleDelayed]
          f@@EinsteinArray[][Tensor[x,{a},{Void}]],
        (f:func)[Tensor[x,{a_},{Void}][args___]]\[RuleDelayed]
          f@@EinsteinArray[][Tensor[x,{a},{Void}][args]]}]



DeclareIndexFlavor[flavor1:{_Symbol,_},
    flavors:{_Symbol,_}..]:=(DeclareIndexFlavor/@{flavor1,flavors};)

DeclareIndexFlavor[{flavorname_Symbol,flavorform_}]:=
  Module[{},
    IndexFlavors=IndexFlavors/.{flavorname,_}\[Rule]Sequence[];
    IndexFlavors=Join[IndexFlavors,{{flavorname,flavorform}}];
    Which[
      Head[flavorform]===RGBColor,
      Format[flavorname[i_]]:=StyleForm[i,FontColor\[Rule]flavorform],
      True,Format[flavorname[i_]]:=flavorform[i]];
    ]



ToFlavor[toflavor_,fromflavor_:Identity][expr_]:=
  Module[{switchQ,replacement,diffcase},
    If[toflavor=!=Identity\[And]Count[IndexFlavors, {toflavor,_}]\[Equal]0,
      Message[Flavor::notflavor,toflavor];Return[expr]];
    
    switchQ[indx_]:=
      Module[{findx},
        findx=
          If[MemberQ[{Dif,Cov},Head[indx]],
            diffcase=True;First[indx],
            diffcase=False;indx];
        Head[findx]===
            fromflavor\[Or](fromflavor===Identity\[And]
              MemberQ[{Symbol,Integer},Head[findx]]\[And]findx=!=Void)
        ];
    
    replacement=
      If[switchQ[#],
          Which[
            fromflavor===Identity\[And]\[Not]diffcase,toflavor@#,
            fromflavor===Identity\[And]diffcase,(toflavor@#&)/@#,
            \[Not]diffcase,toflavor@@#,
            diffcase,(toflavor@@#&)/@#,
            True,Identity@#],
          Identity@#]&;
    
    expr/.Tensor[label_,upindices_,downindices_]\[RuleDelayed]
        Tensor[label,replacement/@upindices,replacement/@downindices]
    ]



ClearIndexFlavor[args:{{_Symbol,_}..}]:=(ClearIndexFlavor/@args;)

ClearIndexFlavor[{flavor_Symbol,_}]:=ClearIndexFlavor[flavor]

ClearIndexFlavor[flavor1_Symbol,
    flavors__Symbol]:=(ClearIndexFlavor/@{flavor1,flavors};)

ClearIndexFlavor[flavor_Symbol]:=
  Module[{},
    If[Count[IndexFlavors, {flavor,_}]\[Equal]0,
      Message[Flavor::notflavor,flavor];Abort[]];
    IndexFlavors=IndexFlavors/.{flavor,_}\[Rule]Sequence[];
    Format[flavor[i_]]=.
    ]

IndexFlavorQ[flavor_]:=MemberQ[IndexFlavors, {flavor,_}]



GetIndexFlavor[indx_]:=
  Module[{head=Head[indx]},
    Switch[head,
      Cov|Dif,GetIndexFlavor[First[indx]],
      Symbol|Integer,Identity,
      _,If[IndexFlavorQ[head],head,$Failed]]]





kSubsets[l_List,0] := { {} }
kSubsets[l_List,1] := Partition[l,1]
kSubsets[l_List,k_Integer?Positive] := {l} /; (k == Length[l])
kSubsets[l_List,k_Integer?Positive] := {}  /; (k > Length[l])
kSubsets[l_List,k_Integer?Positive] :=
	Join[
		Map[(Prepend[#,First[l]])&,kSubsets[Rest[l],k-1]],
		kSubsets[Rest[l],k]
	]

ContractKroneckers[\[Delta]_][expr_]:=
  (expr//KroneckerAbsorb[\[Delta]])/.tensor:
        Tensor[\[Delta],tup_,tdown_]\[RuleDelayed]
      Module[{r,t,n,nup,indices,up,down,sign,voids},
        n=NDim;
        indices=ParseTermIndices[tensor];
        dummies=indices\[LeftDoubleBracket]1\[RightDoubleBracket];
        t=Length[dummies];
        {up,down}=indices\[LeftDoubleBracket]2\[RightDoubleBracket];
        nup=Length[up];
        If[nup\[NotEqual]Length[down],
          Message[ContractKroneckers::indices,tensor];Abort[]];
        r=t+nup;
        voids=Array[Void&,nup];
        sign=
          Signature[If[MemberQ[dummies, #],#,Unevaluated[Sequence[]]]&/@tup]/
            Signature[
              If[MemberQ[dummies, #],#,Unevaluated[Sequence[]]]&/@tdown];
        sign *
          Which[
            t==0,tensor,
            
            nup>0,(n-r+t)!/(n-r)!  Tensor[\[Delta],{Sequence@@up,
                  Sequence@@voids},{Sequence@@voids,Sequence@@down}],
            True,(n-r+t)!/(n-r)! ]
        ]

FullKroneckerExpand[\[Delta]_][expr_]:=
  (expr//ContractKroneckers[\[Delta]])/.tensor:
        Tensor[\[Delta],_,_]\[RuleDelayed]
      Module[{up,down},
        {up,down}=
          ParseTermIndices[tensor]\[LeftDoubleBracket]2\[RightDoubleBracket];
        If[Length[up]\[NotEqual]Length[down],
          Message[FullKroneckerExpand::indices,tensor];Abort[]];
        Det[Outer[Tensor[\[Delta],{#1,Void},{Void,#2}]&,up,down]]
        ]

PartialKroneckerExpand[\[Delta]_Symbol,order_Integer?Positive,
      suborder_Integer?Positive,expandup_:True][expr_]:=
  expr/.tensor:Tensor[\[Delta],u_,_]/;
        Length[u]==2 order\[And]Length[u]>2suborder\[RuleDelayed]
      Module[{up,down,up1,up2,down1,down2,signs,voids1,voids2},
        {up,down}=
          ParseTermIndices[tensor]\[LeftDoubleBracket]2\[RightDoubleBracket];
        If[Length[up]\[NotEqual]Length[down],
          Message[PartialKroneckerExpand::indices,tensor];Abort[]];
        
        If[expandup=!=False,
          up1=Take[up,suborder];
          up2=Drop[up,suborder];
          down1=kSubsets[down,suborder];
          down2=Complement[down,#]&/@down1;
          
          signs=Signature[#]/Signature[down]&/@
              MapThread[Join[#1,#2]&,{down1,down2}],
          
          down1=Take[down,suborder];
          down2=Drop[down,suborder];
          up1=kSubsets[up,suborder];
          up2=Complement[up,#]&/@up1;
          
          signs=Signature[#]/Signature[up]&/@
              MapThread[Join[#1,#2]&,{up1,up2}]
          ];
        voids1=Array[Void&,suborder];
        voids2=Array[Void&,order-suborder];
        If[expandup,
          
          Plus@@MapThread[#1Tensor[\[Delta],Join[up1,voids1],
                    Join[voids1,#2]]Tensor[\[Delta],Join[up2,voids2],
                    Join[voids2,#3]]&,{signs,down1,down2}],
          
          Plus@@MapThread[#1Tensor[\[Delta],Join[#2,voids1],
                    Join[voids1,down1]]Tensor[\[Delta],Join[#3,voids2],
                    Join[voids2,down2]]&,{signs,up1,up2}]]
        ]



Clear[KroneckerAbsorb]
KAUpTest[i_,termexpr_]:=MemberQ[Part[ParseTermIndices[termexpr],2,1], i]

KADownTest[i_,termexpr_]:=MemberQ[Part[ParseTermIndices[termexpr],2,2], i]

GenNewKATerm[i_,j_][term_]:=
  Module[{uq=Unique[q],u1,newterm},
    u1=If[IndexFlavorQ[Head[i]],Head[i][uq],uq];
    newterm=term//IndexChange[{i,u1}];
    newterm/.u1\[Rule]j
    ]







KroneckerAbsorb[\[Delta]_][expr_]:=
  expr//.{Tensor[\[Delta],{i_,Void},{Void,j_}]term_/;
          KADownTest[i,term]\[RuleDelayed] GenNewKATerm[i,j][term],
      Tensor[\[Delta],{j_,Void},{Void,i_}]term_/;
          KAUpTest[i,term]\[RuleDelayed] GenNewKATerm[i,j][term],
      
      Tensor[\[Delta],{Void,i_},{j_,Void}]term_/;
          KADownTest[i,term]\[RuleDelayed]GenNewKATerm[i,j][term],
      Tensor[\[Delta],{Void,j_},{i_,Void}]term_/;
          KAUpTest[i,term]\[RuleDelayed]GenNewKATerm[i,j][term]}



PermutationPseudotensor[n_]:=
  Module[
    {indxs=Table[Unique[q],{n}],iters},
    iters=MapThread[{#1,1,n}&,{indxs}];
    Table[Signature[indxs],Evaluate[Sequence@@iters]]
    ]



PermutationSymbolRule[e_]:=
  Tensor[e,ups_List,downs_List]/;
      Module[{},
        Which[
          Length[ups]\[NotEqual]NDim,False,
          Length[downs]\[NotEqual]NDim,False,
          \[Not]SameQ@@(Head/@ups),False,
          \[Not]SameQ@@(Head/@downs),False,
          \[Not](And@@(#===Void&/@ups))\[And](And@@(#=!=Void&/@downs)),False,
          \[Not](And@@(#===Void&/@downs))\[And](And@@(#=!=Void&/@ups)),False,
          First[ups]===Void\[And]\[Not](And@@(BaseIndexQ/@downs)),False,
          First[downs]===Void\[And]\[Not](And@@(BaseIndexQ/@ups)),False,
          True,True]
        ]\[RuleDelayed]
    Signature[BaseIndices]If[
        First[ups]===Void,Signature[downs],Signature[ups]]





Attributes[MmatchQ]={HoldAll};
MmatchQ[dummyindx_,newindex_,routine_,mt_,subexpr_]:=
  Module[{partialdenom,dum,dummies,i,upm,upsub,downm,downsub,returnval},
    
    partialdenom[dum_]:=
      Count[subexpr,
          HoldPattern[
            PartialD[_][_,
              b_/;\[Not]FreeQ[{b},dum]]],{0,\[Infinity]}]\[Equal]1;
    
    dummies=First[ParseTermIndices[mt subexpr]];
    If[Length[dummies]==0,Return[False]];
    dummies=Sort[dummies,OrderedQ[{RawIndex[#1],RawIndex[#2]}]&];
    
    upm=Complement[Part[mt,2]/.Void\[Rule]Sequence[]];
    downm=Complement[Part[mt,3]/.Void\[Rule]Sequence[]];
    
    i=Join[upm,downm];
    If[Length[Flatten[i]]\[NotEqual]2,Return[False]];
    If[\[Not](Head[#1]===Head[#2]\[Or]
                Head[#1]===Symbol\[And]BaseIndexQ[#2]\[Or]
                Head[#2]===Symbol\[And]BaseIndexQ[#1])&@@i,Return[False]];
    upsub=Part[ParseTermIndices[subexpr],2,1];
    downsub=Part[ParseTermIndices[subexpr],2,2];
    
    returnval=False;
    Do[
      dum=Part[dummies,i];
      Which[
        
        Length[upm]==2\[And]MemberQ[upm,dum]\[And]MemberQ[downsub,dum],
        dummyindx=dum;
        newindex=First[Complement[upm,{dum}]];
        routine=If[partialdenom[dum],LowerIndex,RaiseIndex];
        returnval=True;
        Return[],
        
        Length[downm]==2\[And]MemberQ[downm,dum]\[And]MemberQ[upsub,dum],
        dummyindx=dum;
        newindex=First[Complement[downm,{dum}]];
        routine=If[partialdenom[dum],RaiseIndex,LowerIndex];
        returnval=True;
        Return[],
        
        Length[upm]==1\[And]MemberQ[upm,dum]\[And]MemberQ[downsub,dum],
        dummyindx=dum;
        newindex=First[downm];
        routine=ReplaceIndex;
        returnval=True;
        Return[],
        
        Length[downm]==1\[And]MemberQ[downm,dum]\[And]MemberQ[upsub,dum],
        dummyindx=dum;
        newindex=First[upm];
        routine=ReplaceIndex;
        returnval=True;
        Return[]
        ],
      {i,1,Length[dummies]}];
    
    returnval
    ]



MSSelect[g_,gt_,subexpr_,dummy_]:=
  (MatchQ[gt,
        Tensor[g,{_,Void},{Void,_}]|
          Tensor[g,{Void,_},{_,Void}]])\[Or]((Position[{subexpr}, 
              HoldPattern[
                PartialD[labs_][
                    args__]/;(\[Not]FreeQ[{args},dummy])]]==={})\[And]
        (Position[{subexpr},
              Tensor[args__]/;(\[Not]FreeQ[{args},
                        dummy])\[And](\[Not]FreeQ[{args},
                        Dif[_]])]==={})\[And]
        (Position[{subexpr}, 
              HoldPattern[TotalD[args__]/;(\[Not]FreeQ[{args},dummy])]]==={}))



MetricSimplify[g_,dopartials_:False][expr_]:=
  Which[
    Head[expr]===Equal,MetricSimplify[g,dopartials][Expand[#]]&/@expr,
    Head[expr]===Plus,MetricSimplify[g,dopartials]/@expr,
    True,MetricSimplify2[g,dopartials][expr//Expand]]

MetricSimplify2[g_,dopartials_][expr_]:= 
  Module[{gten,tpatt,dummy,newindex,routine,wexpr},
    gten=Tensor[g,{_,_},{_,_}];
    wexpr=
      expr//.(gt:gten) subexpr_+a_./;
            MmatchQ[dummy,newindex,routine,gt,
                subexpr]\[And](dopartials\[Or]
                  MSSelect[g,gt,subexpr,dummy])\[RuleDelayed]
           Module[{b,postensor},
            
            
            
            postensor=
              Position[subexpr,Tensor[_,b__]/;\[Not]FreeQ[{b},dummy]];
            
            
            ReplacePart[subexpr, 
                routine[dummy,newindex][First[Extract[subexpr,postensor]]], 
                postensor]+a
            ];
    wexpr/.a:(Tensor[g,{i_?BaseIndexQ,Void},{Void,j_?BaseIndexQ}]|
              Tensor[g,{Void,j_?BaseIndexQ},{i_?BaseIndexQ,
                  Void}])\[RuleDelayed]
         Which[Head[i]=!=Head[j],a,
          i===j,1,
          True,0]
        ]











UseCoordinates[namelist_List/;Length[namelist]\[Equal]NDim,x_:Global`x,
      flavor_:Identity][expr_]:=
  expr/.Thread[
      Table[Tensor[
              x,{BaseIndices\[LeftDoubleBracket]
                  i\[RightDoubleBracket]},{Void}]//ToFlavor[flavor],{i,1,
            NDim}]\[Rule]namelist]

UseCoordinates[x_:Global`x,flavor_:Identity][expr_]:=
  If[Length[BaseIndices]>0\[And]And@@(Head[#]===Symbol&/@BaseIndices),
    UseCoordinates[BaseIndices,x,flavor][expr],expr]

CoordinatesToTensors[coordinates_List,xlab_:Global`x,flavor_:Identity][expr_]:=
  
  expr/.Thread[
      coordinates\[Rule]
        Table[Tensor[xlab,{flavor@Part[BaseIndices,i]},{Void}],{i,1,NDim}]]





SymmetrizeSlots[label_,order_,symmetry:{-1|1,{_,__}}][expr_]:=
  SymmetrizeSlots[label,order,{symmetry}][expr]

SymmetrizeSlots[label_,order_,symmetries:{{-1|1,{_,__}}..}][expr_]:=
    expr/.x:Tensor[label,up_List,down_List]/;
          Length[up]==Length[down]==order\[RuleDelayed]
        
        Module[{slots,slotindices,sign=1,symsign,symslots,symindices,
            symordering,n=Length[symmetries],i,temp},
          slots=Transpose[{up,down}];
          slotindices = Flatten[slots]/.Void\[Rule]Sequence[];
          Do[
            {symsign,symslots}=
              symmetries\[LeftDoubleBracket]i\[RightDoubleBracket];
            
            symindices=
              slotindices\[LeftDoubleBracket]symslots\[RightDoubleBracket];
            symordering=Ordering[symindices];
            
            sign*=If[symsign==1,1,
                If[Max[Length/@Split[Sort[Part[slotindices,symslots]]]]>1,0,
                  Signature[symordering]]];
            slots\[LeftDoubleBracket]symslots\[RightDoubleBracket]=
              slots\[LeftDoubleBracket]
                  symslots\[RightDoubleBracket]\[LeftDoubleBracket]
                symordering\[RightDoubleBracket];
            
            slotindices \[LeftDoubleBracket]symslots\[RightDoubleBracket]=
              slotindices \[LeftDoubleBracket]
                  symslots\[RightDoubleBracket]\[LeftDoubleBracket]
                symordering\[RightDoubleBracket],
            {i,1,n}];
          sign Tensor[label,Sequence@@Transpose[slots]]
          ];

SymmetrizeSlots[][expr_]:=
  Module[{},
    expr/.x:Tensor[sym_,up_,down_]/;
          MatchQ[TensorSymmetries[sym,Length[up]],List[___]]\[RuleDelayed]
        SymmetrizeSlots[sym,Length[up],TensorSymmetries[sym,Length[up]]][x]]



SymmetrizePattern[][expr_]:=
  Fold[SymmetrizePattern[Sequence@@#2][#1]&,expr,PatternSymmetries]

SymmetrizePattern[pattern_,
      insymmetries:{{-1|
                1,{_?SymbolicIndexQ,__?
                    SymbolicIndexQ}|{{_?SymbolicIndexQ,__?
                      SymbolicIndexQ},{_?SymbolicIndexQ,__?
                        SymbolicIndexQ}..}}..}][expr_]:=Module[{symmetries},
    symmetries=insymmetries/.{i_Integer,sym_List}\[RuleDelayed]{i,Sort[sym]};
    SymmetrizePattern2[pattern,symmetries][expr]]

SymmetrizePattern2[pattern_,symmetries_][expr_]:=
  Module[{h,i,symlength=Length[symmetries]},
    expr/.(term:h_. pattern)\[RuleDelayed]
        Module[{wterm=term/h,fromindices,toindices,sign},
          Do[
            fromindices=Part[symmetries,i,2];
            toindices=Sort[Part[symmetries,i,2]];
            sign=Switch[Part[symmetries,i,1],
                1,1,
                -1,Signature[fromindices]Signature[toindices]];
            
            wterm=sign wterm/.Thread[
                  Flatten[fromindices]\[Rule]Flatten[toindices]],
            {i,1,symlength}];
          h wterm]
    ]



DeclareTensorSymmetries[symbol_,order_,symmetries:{-1|1,{_,__}}]:=
    DeclareTensorSymmetries[symbol,order,{symmetries}];

DeclareTensorSymmetries[symbol_,order_,
    symmetries:{{-1|1,{_,__}}..}]:=(TensorSymmetries[symbol,order]=
        symmetries;)



DeclarePatternSymmetries[pattern_,
    symmetries:{{-1|
              1,{_?SymbolicIndexQ,__?
                  SymbolicIndexQ}|{{_?SymbolicIndexQ,__?
                    SymbolicIndexQ},{_?SymbolicIndexQ,__?
                      SymbolicIndexQ}..}}..}]:=(PatternSymmetries=
        Union[Join[{{pattern,symmetries}},PatternSymmetries]];)

DeclarePatternSymmetries[
    args:{_,{{-1|1,{_?SymbolicIndexQ,__?
                      SymbolicIndexQ}|{{_?SymbolicIndexQ,__?
                        SymbolicIndexQ},{_?SymbolicIndexQ,__?
                          SymbolicIndexQ}..}}..}}..]:=
  (DeclarePatternSymmetries@@@{args};)



Symmetric[args__/;Length[{args}]>1][term_]:=
  Fold[Symmetric[#2][#1]&,term,{args}]

\!\(\(Symmetric[ind_]\)[term_] := \[IndentingNewLine]Module[{indperm, rules, tens, upindices, downindices, numindices = Length[ind], work = Expand[term], kk}, \[IndentingNewLine]\[IndentingNewLine]Switch[Head[work], \[IndentingNewLine]List, Symmetric[ind] /@ work, \[IndentingNewLine]Equal, Symmetric[ind] /@ work, \[IndentingNewLine]Plus, Symmetric[ind] /@ work, \[IndentingNewLine]_, \[IndentingNewLine]{upindices, downindices} = Part[ParseTermIndices[work], 2]; \[IndentingNewLine]If[Count[ind, Alternatives @@ Flatten[{upindices, downindices}]] \[Equal] 0, Return[work]]; \[IndentingNewLine]If[\[Not] \((Count[ind, Alternatives @@ upindices] \[Equal] numindices \[Or] Count[ind, Alternatives @@ downindices] \[Equal] numindices)\), \[IndentingNewLine]Message[Symmetric::indices, ind, upindices, downindices]; Abort[]]; \[IndentingNewLine]indperm = Permutations[ind]; \[IndentingNewLine]rules = \((MapThread[Rule, {ind, #1}] &)\) /@ indperm; \[IndentingNewLine]tens = Table[work /. Tensor[label_, ups_, downs_] \[RuleDelayed] Tensor[label, ups /. Part[rules, kk], downs /. Part[rules, kk]], {kk, 1, Length[rules]}]; \[IndentingNewLine]Plus @@ tens\/Length[indperm]]\[IndentingNewLine]]\)



AntiSymmetric[args__/;Length[{args}]>1][term_]:=
  Fold[AntiSymmetric[#2][#1]&,term,{args}]

\!\(\(AntiSymmetric[ind_]\)[term_] := \[IndentingNewLine]Module[{indperm, rules, signs, tens, upindices, downindices, numindices = Length[ind], work = Expand[term], kk}, \[IndentingNewLine]\[IndentingNewLine]Switch[Head[work], \[IndentingNewLine]List, AntiSymmetric[ind] /@ work, \[IndentingNewLine]Equal, AntiSymmetric[ind] /@ work, \[IndentingNewLine]Plus, AntiSymmetric[ind] /@ work, \[IndentingNewLine]_, \[IndentingNewLine]{upindices, downindices} = Part[ParseTermIndices[term], 2]; \[IndentingNewLine]If[\[Not] \((Count[ind, Alternatives @@ upindices] \[Equal] numindices \[Or] Count[ind, Alternatives @@ downindices] \[Equal] numindices)\), \[IndentingNewLine]Message[AntiSymmetric::indices, ind, upindices, downindices]; Abort[]]; \[IndentingNewLine]indperm = Permutations[ind]; \[IndentingNewLine]signs = \((Signature[##1] &)\) /@ indperm; rules = \((MapThread[Rule, {ind, #1}] &)\) /@ indperm; \[IndentingNewLine]tens = Table[work /. Tensor[label_, ups_, downs_] \[RuleDelayed] Tensor[label, ups /. Part[rules, kk], downs /. Part[rules, kk]], {kk, 1, Length[rules]}]; \[IndentingNewLine]\(Signature[ind]\ signs . tens\)\/Length[indperm]]]\)



DefineTensorShortcuts[args:{_,_}..]:=(DefineTensorShortcuts@@#&/@{args};)

DefineTensorShortcuts[labels_List,
    order_Integer?Positive]:=(DefineTensorShortcuts[#,order]&/@labels;)

DefineTensorShortcuts[lab_,order_Integer?Positive]:=
  Module [{suffixes={"u","d"},names,udpattern,upindices,downindices,indices},
    names=
      Flatten[Outer[Symbol[SymbolName[lab]<>##]&,
          Sequence@@Table[suffixes,{order}]]];
    udpattern=Outer[{##}&,Sequence@@Table[suffixes,{order}]];
    upindices=
      Flatten[Map[If[#==="u",Unique["u"],Void]&,udpattern,{order+1}],
        order-1];
    downindices=
      Flatten[Map[If[#==="d",Unique["d"],Void]&,udpattern,{order+1}],
        order-1];
    udpattern=Join[{names},{upindices},{downindices}]//Transpose;
    Clear@@names;
    Module[{indices},
              indices=Flatten[Transpose[{#2,#3}]]/.Void\[Rule]Sequence[];
              indices=Pattern[#,Blank[]]&/@indices;
              Evaluate[#1@@indices]:=Tensor[lab,#2,#3]]&@@#&/@udpattern;
    ]

ClearTensorShortcuts[args:{_,_}..]:=(ClearTensorShortcuts@@#&/@{args};)

ClearTensorShortcuts[labels_List,
    order_Integer?Positive]:=(ClearTensorShortcuts[#,order]&/@labels;)

ClearTensorShortcuts[lab_,order_Integer?Positive]:=
  Module [{suffixes={"u","d"},names},
    names=
      Flatten[Outer[Symbol[SymbolName[lab]<>##]&,
          Sequence@@Table[suffixes,{order}]]];
    Clear@@names;
    ]



TensorValueRules[labels__]/;Length[{labels}]>1:=
  Fold[Join,{},
    If[Head[TensorValueRules[#]]===TensorValueRules,{},
          TensorValueRules[#]]&/@{labels}]



Attributes[SetTensorValues]={HoldFirst};

SetTensorValues[tensor_,value_]/;MatchQ[Hold[tensor],Hold[Tensor[_]]]:=
  Module[{label},
    ClearTensorValues[tensor];
    label=Part[tensor,1];
    With[{form=Tensor[label],val=value},
      Evaluate[label]/:form=val];
    ]

SetTensorValues[intensor_,values_List,permissive_:False]:=
  Module[
    {tensor=intensor,wtensor,label,indices,windices,iterators,val},
    
    If[\[Not](permissive\[Or]SameQ@@Join[Dimensions[values],{NDim}]),
      Message[SetTensorValues::size];Return[$Failed]];
    ClearTensorValues[tensor];
    
    indices=Sort[RawIndex/@Flatten[Part[ParseTermIndices[tensor],{1,2}]]];
    windices=Unique/@indices;
    iterators=Map[{#,1,NDim}&,indices]/.Thread[indices\[Rule]windices];
    label=First[tensor];
    wtensor=MapAt[(#/.Thread[indices\[Rule]windices])&,tensor,{{2},{3}}];
    
    Do[
      With[
        {form=wtensor/.Thread[Range[NDim]\[Rule]BaseIndices],
          val=Part[values,Sequence@@windices]},
        Evaluate[label]/:form=val],
      Evaluate[Sequence@@iterators]]
    ]



Attributes[SetTensorValueRules]={HoldFirst};

SetTensorValueRules[tensor_,value_]/;MatchQ[Hold[tensor],Hold[Tensor[_]]]:=
  Module[{label},
    ClearTensorValues[tensor];
    label=Part[tensor,1];
    TensorValueRules[label]=
      Switch[Head[TensorValueRules[label]],
        List,Join[TensorValueRules[label],{Tensor[label]\[Rule]value}],
        _,{Tensor[label]\[Rule]value}];
    ]

SetTensorValueRules[intensor_,values_List,permissive_:False]:=
  Module[
    {tensor=intensor,wtensor,label,indices,windices,iterators,val,newrules},
    
    If[\[Not](permissive\[Or]SameQ@@Join[Dimensions[values],{NDim}]),
      Message[SetTensorValues::size];Return[$Failed]];
    ClearTensorValues[tensor];
    
    indices=Sort[RawIndex/@Flatten[Part[ParseTermIndices[tensor],{1,2}]]];
    windices=Unique/@indices;
    iterators=Map[{#,1,NDim}&,indices]/.Thread[indices\[Rule]windices];
    label=First[tensor];
    wtensor=MapAt[(#/.Thread[indices\[Rule]windices])&,tensor,{{2},{3}}];
    
    newrules=
      Table[
          val=Part[values,Sequence@@windices];
          With[{form=wtensor/.Thread[Range[NDim]\[Rule]BaseIndices]},
            form\[Rule]val],
          Evaluate[Sequence@@iterators]]//Flatten;
    
    TensorValueRules[label]=
      Switch[Head[TensorValueRules[label]],
        List,Join[TensorValueRules[label],newrules],
        _,newrules];
    ]



Attributes[ClearTensorValues]={HoldFirst};
ClearTensorValues[tensorlist_]/;MatchQ[Hold[tensorlist],Hold[List[__]]]:=
  (Map[ClearTensorValues,Hold[tensorlist],{2}]//ReleaseHold;)

ClearTensorValues[intensor_]:=
  Module[
    {tensor,label,p,form,upindices,downindices,upflavors,downflavors,ups,
      downs},
    
    Switch[Hold[intensor],
      Hold[Tensor[_]],
      label=Part[Hold[intensor],1,1];
      form=HoldPattern[Tensor[p]]/.p\[Rule]label,
      _,
      tensor=intensor;
      label=Part[tensor,1];
      upindices=Part[tensor,2];
      downindices=Part[tensor,3];
      upflavors=GetIndexFlavor/@upindices;
      downflavors=GetIndexFlavor/@downindices;
      form=
        Tensor[label,
            ups:Map[If[#===Void,Void,_]&,upindices],
            downs:Map[If[#===Void,Void,_]&,downindices]]/;(upflavors===
                GetIndexFlavor/@ups)\[And](downflavors===
                GetIndexFlavor/@downs)
      ];
    
    With[{wform=form,wlabel=label},
      UpValues[wlabel]=Select[UpValues[wlabel],FreeQ[#,wform]&];
      TensorValueRules[wlabel]=
        If[Head[TensorValueRules[wlabel]]===TensorValueRules,{},
          Select[TensorValueRules[wlabel],FreeQ[First[#],wform]&]]];
    ]



NonzeroValueRules[labels__]:=
  Cases[TensorValueRules[labels],HoldPattern[Rule[_,rhs_/;rhs=!=0]]]



SelectedTensorRules[label_,pattern_]:=
  Module[{work},
    work=NonzeroValueRules[label];
    Select[work,MatchQ[First[#],pattern]&]
    ]



DeclareZeroTensor[lab_]:=
  lab/:Tensor[
      lab,{_?(FreeQ[#,
                    Pattern]\[And](#===Void\[Or]
                      BaseIndexQ[#])&)..},{_?(FreeQ[#,
                    Pattern]\[And](#===Void\[Or]BaseIndexQ[#])&)..}]:=0



SetMetricValueRules[g_,MT_,flavor_:Identity]:=
  Module[{i,j},
    SetTensorValueRules[Tensor[g,{Void,Void},{i,j}]//ToFlavor[flavor],MT];
    SetTensorValueRules[Tensor[g,{i,j},{Void,Void}]//ToFlavor[flavor],
      Simplify[Inverse[MT]]]
    ]

SetMetricValues[g_,MT_,flavor_:Identity]:=
  Module[{i,j},
    SetTensorValues[Tensor[g,{Void,Void},{i,j}]//ToFlavor[flavor],MT];
    SetTensorValues[Tensor[g,{i,j},{Void,Void}]//ToFlavor[flavor],
      Simplify[Inverse[MT]]]
    ]

\!\(\(\[CapitalGamma]\^\[Lambda]\)\_\[Mu]\[Nu] = \(1\/2\) \(g\^\[Lambda]\[Sigma]\) \((\[PartialD]\_\[Mu]\ g\_\[Sigma]\[Nu] + \[PartialD]\_\[Nu]\ g\_\[Sigma]\[Mu] - \[PartialD]\_\[Sigma]\ g\_\[Mu]\[Nu])\)\)



extractFlavor[x_Tensor]:=
  Module[{flavor},
    flavor=Head[Part[x,2,1]];
    Which[
      IndexFlavorQ[flavor],flavor,
      flavor===Symbol,Identity,
      True,Message[Flavor::notflavor,flavor];Abort[]]]



CalculateChristoffelu[x_Tensor,MT_,simplifyfunc_:Identity]:=
  Module[
    {G,DD,d,l,m,n,s,ll,mm,nn,ss,Chr,flavor},
    d = Length[MT];
    flavor=extractFlavor[x];
    SetMetricValueRules[G,  MT,flavor];
    
    Gdd[s_,n_]=Tensor[G,{Void,Void},{s,n}]//ToFlavor[flavor];
    Guu[s_,n_]=Tensor[G,{s,n},{Void,Void}]//ToFlavor[flavor];
    xu[n_]=Tensor[First[x],{n},{Void}]//ToFlavor[flavor];
    
    Chr=Table[
          l=Part[BaseIndices,ll];
          m=Part[BaseIndices,mm];
          n=Part[BaseIndices,nn];
          Sum[
            s=Part[BaseIndices,ss];
            
            Guu[l,s](DD[Gdd[s,n],xu[m]]+DD[Gdd[s,m],xu[n]]-
                  DD[Gdd[m,n],xu[s]])
            ,{ss,1,d}]
          
          ,{ll,1,d},{mm,1,d},{nn,1,d}]/2;
    Chr=(Chr/.TensorValueRules[G])/.DD\[RuleDelayed]D;
    ClearTensorValues/@{Gdd[mm,nn],Guu[mm,nn]};
    Map[simplifyfunc,Chr,{3}]
    ]

CalculateChristoffeld[x_Tensor,MT_,simplifyfunc_:Identity]:=
    Module[{G,DD,d,m,n,s,mm,nn,ss,Chr,flavor},
      d = Length[MT];
      flavor=extractFlavor[x];
      SetMetricValueRules[G,  MT,flavor];
      
      Gdd[s_,n_]=Tensor[G,{Void,Void},{s,n}]//ToFlavor[flavor];
      Guu[s_,n_]=Tensor[G,{s,n},{Void,Void}]//ToFlavor[flavor];
      xu[n_]=Tensor[First[x],{n},{Void}]//ToFlavor[flavor];
      
      Chr=Table[
            m=Part[BaseIndices,mm];
            n=Part[BaseIndices,nn];
            s=Part[BaseIndices,ss];
            
            DD[Gdd[s,n],xu[m]]+DD[Gdd[s,m],xu[n]]-DD[Gdd[m,n],xu[s]]
            
            ,{ss,1,d},{mm,1,d},{nn,1,d}]/2;
      
      Chr=(Chr/.TensorValueRules[G])/.DD\[RuleDelayed]D;
      ClearTensorValues/@{Gdd[mm,nn],Guu[mm,nn]};
      Map[simplifyfunc,Chr,{3}]
      ];

SetChristoffelValueRules[x_Tensor,MT_,\[CapitalGamma]_,
    simplifyfunc_:Identity]:=
  Module[{l,m,n,flavor},
    flavor=extractFlavor[x];
    SetTensorValueRules[
       Tensor[\[CapitalGamma],{l,Void,Void},{Void,m,n}] //ToFlavor[flavor],
      CalculateChristoffelu[x,MT,simplifyfunc]
      ];
    SetTensorValueRules[
       Tensor[\[CapitalGamma],{Void,Void,Void},{l,m,n}] //ToFlavor[flavor],
      CalculateChristoffeld[x,MT,simplifyfunc]
      ];
    ]

SetChristoffelValues[x_Tensor,MT_,\[CapitalGamma]_,simplifyfunc_:Identity]:=
  Module[{l,m,n,flavor},
    flavor=extractFlavor[x];
    SetTensorValues[
       Tensor[\[CapitalGamma],{l,Void,Void},{Void,m,n}] //ToFlavor[flavor],
      CalculateChristoffelu[x,MT,simplifyfunc]
      ];
    SetTensorValues[
       Tensor[\[CapitalGamma],{Void,Void,Void},{l,m,n}] //ToFlavor[flavor],
      CalculateChristoffeld[x,MT,simplifyfunc]
      ];
    ]





PartialD[u_?NumericQ,__]:=0;

PartialD[u_Symbol,__]:=0;



PartialD[a_ b_,c_]/;FreeQ[a,Tensor[__]]:=a PartialD[b,c]

PartialD[Tensor[T_,sup_,sub_],j_]:=Module[{},
        newup = Map[Void&,j];
        newsub=Map[Dif,j];
        Tensor[T,Join[sup,newup],Join [sub,newsub]]
         ]/;VectorQ[j];

PartialD[Tensor[T_,sup_,sub_],j_]:=Module[{},
        Tensor[T,Join[sup,{Void}],Join [sub,{Dif[j]}]]
         ]/;Not[VectorQ[j]];

PartialD[w_Plus,j_]:=(PartialD[#1,j]&)/@w;

PartialD[w_ u_,j_]:=PartialD[w,j] u+PartialD[u,j] w/;VectorQ[j]===False;

PartialD[Dot[w_ ,u_],j_]:=
    Dot[PartialD[w,j], u]+Dot[PartialD[u,j] ,w]/;VectorQ[j]===False;

PartialD[w_ u_,j_List]:=Fold[PartialD[#1,#2]&,w u,j];



PartialD[Tensor[T_],j_]:=Module[{},
    Tensor[T,{Void},{Dif[j]}]
     ]

PartialD[Tensor[T_],j_List]:=Module[{up,sub},
    up=(Void&)/@j;
    sub=Dif/@j;
    Tensor[T,up,sub]]



GetDif[Tensor[T_,sup_,sub_]]:=
    Module[{x,sub2,sub3},
      sub2=Cases[sub,Dif[_]] ;  
      sub3=sub2/.Dif[x_]\[Rule]x
      ];

DropDif[Tensor[T_,sup_,sub_]]:=Module[{indT},
      indT=Transpose[{sup,sub}]/.{Void,Dif[_]}\[Rule]Sequence[];
      If[indT\[Equal]{},Tensor[T],Tensor[T,Sequence@@Transpose[indT]   ]]
      ];

ExpandPartialD[{x_,\[Delta]_,g_,\[CapitalGamma]_}][w_]:=
    Module[{ind},
      w/.Tensor[T_,ind__]\[RuleDelayed] 
          PartialD[{x,\[Delta],g,\[CapitalGamma]}][   
            DropDif[Tensor[T,ind ]]    , 
            Map[Tensor[x,{#} ,{Void}]&,GetDif[Tensor[T,ind  ]]  ] ]
      ];



PartialD[{x_,\[Delta]_,g_,\[CapitalGamma]_}][w_,v_List]:=
    D[w,Sequence@@v]/;FreeTensorQ[w]&&(And@@Map[FreeTensorQ[#]&,v]);

PartialD[{x_,\[Delta]_,g_,\[CapitalGamma]_}][w_,v_]:=
  D[w,v]/;FreeTensorQ[w]&&FreeTensorQ[v]





PartialD[labs_List][a_ b_,c_]/;FreeQ[a,Tensor[__]|c]\[And]FreeQ[c,Tensor[__]]:=
  a PartialD[labs][b,c]

PartialD[_][ a_?NumericQ  , _ ] := 0;

PartialD[_][u_Symbol,v__ ]:=0/;MemberQ[Attributes[u],Constant]

PartialD[labels_][ T_Plus , v_ ]:= PartialD[labels][#,v]& /@ T;

HoldPattern[PartialD[labels_][Dot[w_ ,u_],j_]]:=
    Dot[PartialD[labels][w,j], u]+Dot[PartialD[labels][u,j] ,w]/;
      VectorQ[j]===False;

PartialD[labels_][ T_*U_ , v_ ]:= 
    PartialD[labels][T,v]*U + T*PartialD[labels][U,v]/;
      VectorQ[v]\[Equal]False;

PartialD[w_ ,{}]:=w;

PartialD[labs_][w_ ,{}]:=w;

PartialD[w_ ,{i_}]:=PartialD[w ,i];

PartialD[labs_][w_ ,{i_}]:=PartialD[labs][w,i];



PartialD[labs_][T_,u_List]/;\[Not]OrderedQ[u]:=PartialD[labs][T,Sort[u]]



PartialD[{x_,\[Delta]_,g_,\[CapitalGamma]_}][ Tensor[x_,{i_},{Void}] ,
        Tensor[x_,{j_},{Void}] ]/;(Head[i]===Head[j]&&Not[VectorQ[j]])=
    Tensor[\[Delta],{i,Void},{Void,j}];

PartialD[{x_,\[Delta]_,g_,\[CapitalGamma]_}][ Tensor[x_,{Void},{i_}] ,
        Tensor[x_,{Void},{j_}] ]/;(Head[i]===Head[j]&&Not[VectorQ[j]])=
    Tensor[\[Delta],{j,Void},{Void,i}];

FilterPD[Void,Void]:=Sequence[];
FilterPD[i_,Void]:=i;
FilterPD[Void,i_]:=i;
HoldPattern[
    PartialD[{x_,\[Delta]_,g_,\[CapitalGamma]_}][ Tensor[x_,U1:{__},U2_] ,
      Tensor[x_,V__] ]]:=Module[{ind},
      ind=MapThread[FilterPD,MapAt[  Reverse[#]&,{{U1,U2},{V}},2],2];
      Times@@
        Map[Tensor[\[Delta],{#[[1]],Void},{Void,#[[2]]}]&,Transpose[ind]  ]
      ]/;(Count[
            ind=MapThread[FilterPD,MapAt[  Reverse[#]&,{{U1,U2},{V}},2],2],
            FilterPD[__],2]\[Equal]0)&&(And@@
          MapThread[(Head[#1]===Head[#2])&,Append[Transpose[ind],{1,2}]  ])


PartialD[{x_,\[Delta]_,g_,\[CapitalGamma]_}][Tensor[\[Delta]_,__],_]:=0



PartialD[{x_,\[Delta]_,g_,\[CapitalGamma]_}][
        Tensor[x_,{i_},{Void}],{___,Tensor[x_,{j_},{Void}],___,
          Tensor[x_,{k_},{Void}],___}]/;
      Head[i]===Head[j]\[And]Head[i]===Head[k]=0;



PartialD[labels_][   PartialD[labels_][    T_ , u_ ] , v_ ]:=
    PartialD[labels][   T ,Flatten[{v,u}] ];

PartialD[labels_][T_Times ,u_List]:=Fold[ PartialD[labels][  #1 ,#2 ]&,T,u];



HoldPattern[PartialD[lab_][ f_[g_],t_List]]:= 
    Fold[  PartialD [lab][#1,#2]&  ,  f[g]  , t   ] /;
      Not[MemberQ[{Tensor,TotalD,AbsoluteD,LieD,CovariantD,PVector},f]];



HoldPattern[PartialD[lab_][  F_[g_]  ,T_ ]]:=
    Derivative[1][F][g]*PartialD[lab][ g,T  ]/;
      Not[MemberQ[{Tensor,TotalD,AbsoluteD,LieD,CovariantD,PVector},F]\[Or]
          MatchQ[g,
            Tensor[Part[lab,
                1],{i_?(\[Not]MemberQ[BaseIndices, #]&)},{Void}] ]];

HoldPattern[PartialD[lab_][  Power[g_,n_]  ,T_ ]]:=
  Derivative[1,0][Power][g,n]*PartialD[lab][ g,T  ]+
      Derivative[0,1][Power][g,n]*PartialD[lab][ n,T  ]/;Not[VectorQ[T]]

HoldPattern[PartialD[lab_][  Power[g_,n_]  ,{T_,S__}]]:=
  PartialD[lab][
    Derivative[1,0][Power][g,n]*PartialD[lab][ g,T  ]+
      Derivative[0,1][Power][g,n]*PartialD[lab][ n,T  ]
    ,{S}]

HoldPattern[ PartialD[lab_][ f_[g__],{t_,s__}] ]:= 
    PartialD[lab][   PartialD[lab][f[g],t]   ,{s}]/;
      Not[MemberQ[{Tensor,TotalD,AbsoluteD,LieD,CovariantD,PVector},f]]&&
        Not[MatchQ[f,PartialD[_]]];



HoldPattern[PartialD[lab_][ f_[g__],t_ ]
      ]:=Plus@@
        MapThread[
          Derivative[Sequence@@#1][f][g]PartialD[lab][#2,t]&,{IdentityMatrix[
              Length[{g}]],{g}}]/;
      Not[MemberQ[{Tensor,TotalD,AbsoluteD,LieD,CovariantD,PVector},f]]&&
        Not[MatchQ[f,PartialD[_]]]&&Not[VectorQ[t]]&&
        Not[Length[{g}]\[Equal]1\[And]
            MatchQ[g,
              Tensor[Part[lab,
                  1],{i_?(\[Not]MemberQ[BaseIndices, #]&)},{Void}] ]];



NondependentPartialD[qin__?VectorQ][expr_]:=
  Module[{partialtest,q={qin}},
    
    partialtest[t_,partialsin_]:=
      Module[{partials,partiallabs},
        partials=If[Head[partialsin]===List,partialsin,{partialsin}];
        partiallabs=Cases[partials, Tensor[lab_,___]\[Rule]lab];
        
        Or@@(If[MemberQ[#,t],Intersection[Complement[#,{t}],partiallabs]=!={},
                  False]&/@q)
        ];
    
    expr/.PartialD[_][Tensor[t_,ind___],p_]/;partialtest[t,p]\[RuleDelayed]0
    ]





CovariantD[_?NumericQ,_]:=0;
CovariantD[w_Symbol,_]:=0;

(*Addition: 11/7/2003*)
CovariantD[w_,_]:=0/;Count[w,Tensor[__],{0,\[Infinity]}]===0

CovariantD[Tensor[T_,sup_,sub_],j_List]/;VectorQ[j]:=
    Module[{newup,newsub},
      newup=(Void&)/@j;
      newsub=Cov/@j;
      Tensor[T,Join[sup,newup],Join[sub,newsub]]];

CovariantD[Tensor[T_,sup_,sub_],j_]/;!VectorQ[j]:=
    Tensor[T,Join[sup,{Void}],Join[sub,{Cov[j]}]];



CovariantD[Tensor[T_],j_]/;!VectorQ[j]:=PartialD[Tensor[T],j];

CovariantD[Tensor[T_],{j_}]:=CovariantD[Tensor[T],j];

CovariantD[Tensor[T_],j_]/;VectorQ[j]:=Module[{ind1},
    ind1=First[j];
    CovariantD[ CovariantD[Tensor[T],ind1] ,  Drop[j,1] ]
    ]

CovariantD[w_Plus,j_]:=(CovariantD[#1,j]&)/@w;

CovariantD[w_ u_,j_]:=CovariantD[w,j] u+CovariantD[u,j] w/;VectorQ[j]==False;

CovariantD[w_ u_,j_List]:=Fold[CovariantD[#1,#2]&,w u,j];



ExpandCovariantD[labels_,dummy_][T_Plus]:=ExpandCovariantD[labels,dummy]/@T;

ExpandCovariantD[labels_,dummy_][T_*V_]:=
    T*ExpandCovariantD[labels,dummy][V]/;FreeCovQ[T];

ExpandCovariantD[labels_,{dummy1_,dummy2__}][T_*V_]:=
    ExpandCovariantD[labels,dummy1][T]*
        ExpandCovariantD[labels,{dummy2}][V]/;(Not[FreeCovQ[T]]&&
          Not[FreeCovQ[V]]);

ExpandCovariantD[labels_,{a_}][T_]:=ExpandCovariantD[labels,a][T];

ExpandCovariantD[__][  T_ ]:=T /;FreeCovQ[T];

GetCovIndices[Tensor[T_,sup_,sub_]]:=
    Module[{x,sub2,sub3},
      sub2=Cases[sub,Cov[_]];
      sub3=sub2/.\[InvisibleSpace]Cov[x_]\[Rule]x;
      If[Length[sub3]==1,Sequence@@sub3,sub3]];

DropCov[Tensor[T_,sup_,sub_]]:=
    Module[{indT},
      indT=
        Transpose[{sup,sub}]/.\[InvisibleSpace]{Void,Cov[_]}\[Rule]Sequence[];
      Tensor[T,Sequence@@Transpose[indT]]];



ChangeIndexToDummy[T_,{i_,Void},a_]:=T/.Verbatim[\[InvisibleSpace]i]\[Rule]a;
ChangeIndexToDummy[T_,{Void,i_},a_]:=T/.Verbatim[\[InvisibleSpace]i]\[Rule]a;

ChristoffelFactor[{x_,g_,\[CapitalGamma]_},dummy_,DifInd_,{i_,Void}]:= 
    Tensor[\[CapitalGamma],{i,Void,Void},{Void,DifInd,dummy}];

ChristoffelFactor[{x_,g_,\[CapitalGamma]_},dummy_,
      DifInd_,{Void,
        i_}]:= -Tensor[\[CapitalGamma],{dummy,Void,Void},{Void,DifInd,i}];

ChristoffelTerms[{x_,g_,\[CapitalGamma]_},T_,dummy_,DifInd_,indt_]:=
    Module[{},
      Map[ ChangeIndexToDummy[T ,#,dummy]&,  indt ].Map[
          ChristoffelFactor[{x,g,\[CapitalGamma]},dummy,DifInd,#]&, indt]
      ];



ExpandCovariantD[{x_,\[Delta]_,g_,\[CapitalGamma]_},a_][ 
    Tensor[T_,{Void,Void},{Dif[i_],Cov[j_]}] 
    ]:=Module[{DTx},
    DTx=PartialD[{x,\[Delta],g,\[CapitalGamma]}][ Tensor[T] , 
        Tensor[x,{i},{Void}]  ];
    ExpandCovariantDXX[{x,\[Delta],g,\[CapitalGamma]}][{DTx,{Void},{i}},{j,
          a}]\[LeftDoubleBracket]1\[RightDoubleBracket]
    ]



ExpandCovariantD[{x_,\[Delta]_,g_,\[CapitalGamma]_},a_List][ 
    Tensor[T_,{Void..},ind:{Dif[i_],Cov[_]..}] 
    ]:=Module[{DTx,covi},
    covi=Drop[ind,1]/.Cov\[Rule]Sequence;
    indT=Transpose[{covi,a}];
    DTx=PartialD[{x,\[Delta],g,\[CapitalGamma]}][ Tensor[T] , 
        Tensor[x,{i},{Void}]  ];
    
    Fold[
        ExpandCovariantDXX[{x,\[Delta],
                g,\[CapitalGamma]}][#1,{#2[[1]],#2[[2]]}]&,
        {DTx,{Void},{i}},indT][[1]]
    ]



ExpandCovariantD[{x_,\[Delta]_,g_,\[CapitalGamma]_},a_][Tensor[T_,sup_,sub_]]:=
    
    Module[
        {CovInd,DropT,indt},
        CovInd=GetCovIndices[Tensor[T,sup,sub]];
        DropT=DropCov[Tensor[T,sup,sub]];
        indt=
          Transpose[{sup,sub}]/.\[InvisibleSpace]{Void,Cov[_]}\[Rule]
              Sequence[];
        PartialD[{x,\[Delta],g,\[CapitalGamma]}][DropT,
            Tensor[x,{CovInd},{Void}] ]+
          ChristoffelTerms[{x,g,\[CapitalGamma]},DropT,a,CovInd,
            indt]]/;!VectorQ[a];



ExpandCovariantD[{x_,\[Delta]_,g_,\[CapitalGamma]_},dummy_][
      Tensor[T_,sup_,sub_]]:=
    Module[
        {CovInd,DropT,Dropsup,Dropsub},
        CovInd=GetCovIndices[Tensor[T,sup,sub]];
        DropT=DropCov[Tensor[T,sup,sub]];
        Dropsup=DropT\[LeftDoubleBracket]2\[RightDoubleBracket];
        Dropsub=DropT\[LeftDoubleBracket]3\[RightDoubleBracket];
        Fold[
            ExpandCovariantDXX[{x,\[Delta],g,\[CapitalGamma]}],{DropT,Dropsup,
              Dropsub},
            Transpose[{CovInd,
                dummy}]]\[LeftDoubleBracket]1\[RightDoubleBracket]]/;
      VectorQ[dummy];

ExpandCovariantDXX[{x_,\[Delta]_,g_,\[CapitalGamma]_}][{T_,sup_,
        sub_},{CovInd_,Dummy_}]:=
    Module[{indT},
      indT=Transpose[{sup,sub}];
      {PartialD[{x,\[Delta],g,\[CapitalGamma]}][T,Tensor[x,{CovInd},{Void}]]+
          ChristoffelTerms[{x,g,\[CapitalGamma]},T,Dummy,CovInd,indT],
        Append[sup,Void],Append[sub,CovInd ]}
      ];





TotalD[CircleTimes[args__],t__]:=
  Module[{n=Length[{args}],i},
    Sum[CircleTimes@@
        Join[Part[{args},Range[1,i-1]],{TotalD[Part[{args},i],t]},
          Part[{args},Range[i+1,n]]],{i,1,n}]]



TotalD[w_List,j_]:=(TotalD[#1,j]&)/@w;

TotalD[w_List]:=(TotalD[#1]&)/@w;

TotalD[w_Equal,j_]:=(TotalD[#1,j]&)/@w;

TotalD[w_Equal]:=(TotalD[#1]&)/@w;

TotalD[u_?NumericQ,___]:=0;

TotalD[u_,u_]:=1;

TotalD[u_Symbol,v___]:=0/;MemberQ[Attributes[u],Constant];

TotalD[w_Plus,j_]:=(TotalD[#1,j]&)/@w;

TotalD[w_Plus]:=(TotalD[#1]&)/@w;

TotalD[w_*u_,j_]:=TotalD[w,j] u+TotalD[u,j] w/;VectorQ[j]==False;

TotalD[w_*u_]:=TotalD[w] u+TotalD[u] w/;VectorQ[j]==False;

TotalD[w_?FreeTensorQ,t_]:=
    Dt[w,t]/;(Head[w]=!=PartialD)&&(Head[w]=!=TotalD)&&(Head[Head[w]]=!=
            PartialD)&&(Head[w]=!=PVector)&&Not[VectorQ[t]];

TotalD[CircleTimes[args__]]:=
  Module[{n=Length[{args}],i},
    Sum[CircleTimes@@
        Join[Part[{args},Range[1,i-1]],{TotalD[Part[{args},i]]},
          Part[{args},Range[i+1,n]]],{i,1,n}]]

TotalD[w_?FreeTensorQ]:=
    Dt[w]/;(Head[w]=!=PartialD)&&(Head[w]=!=TotalD)&&(Head[Head[w]]=!=
              PartialD)&&(Head[w]=!=PVector)&&Not[VectorQ[t]];



TotalD[ Power[g_,n_],
      t_ ]:=(Derivative[ 1 ,0  ][Power][g,n]TotalD[ g,t]+
          Derivative[ 0 ,1  ][Power][g,n]TotalD[ n,t])/;Not[VectorQ[t]];

TotalD[ Power[g_,n_]]:=(Derivative[ 1 ,0  ][Power][g,n]TotalD[ g]+
        Derivative[ 0 ,1  ][Power][g,n]TotalD[ n]);

TotalD[ f_[g_],t_ ]:=
    Derivative[1][f][g]TotalD[g,t]/;
      f=!=Tensor&&f=!=PVector&&f=!=Times&&f=!=Plus&&f=!=TotalD&&
        Not[MatchQ[f,PartialD[_]]]&&Not[VectorQ[t]];

TotalD[ f_[g_]]:=
    Derivative[1][f][g]TotalD[g]/;
      Not[MemberQ[{Tensor,Times,Plus,TotalD,AbsoluteD,LieD,PVector},f]]&&
        Not[MatchQ[f,PartialD[_]]];

TotalD[ f_[g__],t_ ]:=
    Plus@@MapThread[
          Derivative[Sequence@@#1][f][g]TotalD[#2,t]&,{IdentityMatrix[
              Length[{g}]],{g}}]/;
      Not[MemberQ[{Tensor,Times,Plus,TotalD,AbsoluteD,LieD,PVector},f]]&&
        Not[MatchQ[f,PartialD[_]]]&&Not[VectorQ[t]];

TotalD[ f_[g__]]:=
    Plus@@MapThread[
          Derivative[Sequence@@#1][f][g]TotalD[#2]&,{IdentityMatrix[
              Length[{g}]],{g}}]/;
      Not[MemberQ[{Tensor,Times,Plus,TotalD,AbsoluteD,LieD,PVector},f]]&&
        Not[MatchQ[f,PartialD[_]]];

TotalD[ f_[g_],t_ List]:=
    Fold[Derivative[1][f][g]TotalD[g,#]&,t]/;f=!=Tensor&&f=!=TotalD&&
      f=!=PVector&&Not[MatchQ[f,PartialD[_]]];



TotalD[w_*u_,j_List]:=Fold[ TotalD[#1,#2]&,w*u,j];

TotalD[   HoldPattern[TotalD[    T_ , u_ ]] , v_ ]:=
    TotalD[   T ,Flatten [{u,v}]  ];

TotalD[T_ ,u_List]:=Fold[  TotalD[  #1 ,#2 ]& ,T,u]/;Head[T]=!=Tensor;





ExpandTotalD[args__][
    expr_/;MemberQ[{List,Equal,Plus,Less,Greater,LessEqual,GreaterEqual}, 
        Head[expr]]]:=ExpandTotalD[args]/@expr



ExpandTotalD[labels_,dummy_][T_?NumericQ*V_]:=
    T* ExpandTotalD[labels,dummy][V];



ExpandTotalD[{x_,\[Delta]_,g_,\[CapitalGamma]_},dummy_][    
      HoldPattern[TotalD[ Tensor[x_,ind__] ,t_]*V_]     ]:=
    TotalD[ Tensor[x,ind] ,t]* 
      ExpandTotalD[{x,\[Delta],g,\[CapitalGamma]},dummy][V];



ExpandTotalD[labels_,dummy_][T_*V_]:=
    T* ExpandTotalD[labels,dummy][V]/;FreeTotalDQ[T];



ExpandTotalD[labels_,dummy_][T_]:=T/;FreeTotalDQ[T];



ExpandTotalD[labels_,{a_,dummy__}][T_*V_]:=
    ExpandTotalD[labels,a][T]*ExpandTotalD[labels,{dummy}][V]/;
      Not[FreeTotalDQ[T]]&&Not[FreeTotalDQ[V]];



ExpandTotalD[x_,{a_}][T_]:=ExpandTotalD[x,a][T];



ExpandTotalD[{x_,\[Delta]_,g_,\[CapitalGamma]_},dummy_][   
      HoldPattern[TotalD[T_,v_]]   ]:=
    PartialD[{x,\[Delta],g,\[CapitalGamma]}][T,Tensor[x,{dummy},{Void}]]*
        TotalD[ Tensor[x,{dummy},{Void}]  ,v]/;
      Not[VectorQ[v]]&&Not[VectorQ[dummy]];

ExpandTotalD[{x_,\[Delta]_,g_,\[CapitalGamma]_},dummy_][
      HoldPattern[TotalD[T_]]]:=
    PartialD[{x,\[Delta],g,\[CapitalGamma]}][T,
          Tensor[x,{dummy},{Void}]] TotalD[
          Tensor[x,{dummy},{Void}]]/;!VectorQ[dummy];



ExpandTotalD[{x_,\[Delta]_,g_,\[CapitalGamma]_},dummy_List][
      HoldPattern[TotalD[T_,v_List]]]:=Module[{DummyParam},
      If[Length[dummy]=!=Length[v],Message[ExpandTotalD::dummies,dummy,v];
        Abort[]];
      DummyParam=Transpose[{dummy,v}];
      Fold[ExpandTotalD[{x,\[Delta],
                g,\[CapitalGamma]},#2\[LeftDoubleBracket]1\
\[RightDoubleBracket]][
            TotalD[#1,#2\[LeftDoubleBracket]2\[RightDoubleBracket]]]&,T,
        DummyParam]];





AbsoluteD[u_?NumericQ,_]:=0;



AbsoluteD[u_?FreeTensorQ,t_]/;FreeQ[u,Alternatives@@t]:=0

AbsoluteD[w_Plus,j_]:=(AbsoluteD[#1,j]&)/@w;

AbsoluteD[w_*u_,j_]:=AbsoluteD[w,j] u+AbsoluteD[u,j] w/;VectorQ[j]==False;

AbsoluteD[ Tensor[F_],t_]:=TotalD[Tensor[F],t];



HoldPattern[AbsoluteD[ TotalD[F_,t_],v_]]:=
    TotalD[Tensor[F],Sort@Flatten[{t,v}]];



AbsoluteD[w_*u_,j_List]:=Fold[ AbsoluteD[#1,#2]&,w*u,j];

AbsoluteD[   AbsoluteD[T_ , u_ ] , v_ ]:=AbsoluteD[   T ,Flatten [{u,v}]  ];

AbsoluteD[T_ ,u_List]:=Fold[  AbsoluteD[  #1 ,#2 ]& ,T,u]/;Head[T]=!=Tensor;



ExpandAbsoluteD[args__][
    expr_/;MemberQ[{List,Equal,Plus,Less,Greater,LessEqual,GreaterEqual}, 
        Head[expr]]]:=ExpandAbsoluteD[args]/@expr

AbsoluteDOrderMatchQ[expr_,dummies_]:=
  Module[{work,orderexpr,orderdummies=Length[Flatten[dummies]]},
    work=expr/.a_+b__/;FreeQ[a, AbsoluteD]\[And]FreeQ[b, AbsoluteD]\[Rule]1;
    If[\[Not]FreeQ[work, Plus,{0,1}],Return[False]];
    orderexpr=
      Length[Flatten[Cases[work, AbsoluteD[_,t_]\[RuleDelayed]t,{0,1}]]];
    2orderexpr\[Equal]orderdummies
    ]

ExpandAbsoluteD[_,dummies_][expr_]/;\[Not]AbsoluteDOrderMatchQ[expr,dummies]:=
    expr;





ExpandAbsoluteD[labels_,dummy_][T_?NumericQ*V_]:=
    T* ExpandAbsoluteD[labels,dummy][V];

ExpandAbsoluteD[labels_,{dummy1_,dummy2__}][TotalD[T__]*V_]:=
    TotalD[T]*ExpandAbsoluteD[labels,{dummy2}][V]/;Not[FreeAbsoluteDQ[V]];

ExpandAbsoluteD[labels_,dummy_][T_*V_]:=
    T* ExpandAbsoluteD[labels,dummy][V]/;FreeAbsoluteDQ[T];

ExpandAbsoluteD[labels,dummy_][T_]:=T/;FreeAbsoluteDQ[T];

ExpandAbsoluteD[labels_,{dummy1_,dummy2__}][T_*V_]:=
    ExpandAbsoluteD[labels,dummy1][T]*ExpandAbsoluteD[labels,{dummy2}][V]/;
      Not[FreeAbsoluteDQ[T]]&&Not[FreeAbsoluteDQ[V]];

ExpandAbsoluteD[labels_,{{a_,b_}}][T_]:=ExpandAbsoluteD[labels,{a,b}][T];



ExpandAbsoluteD[{x_,\[Delta]_,g_,\[CapitalGamma]_},{a_,CovInd_}][   
      AbsoluteD[Tensor[T_,sup_,sub_],t_]   ]:=
    Module[
        {indt},
        indt=Transpose[{sup,sub}];
        TotalD[Tensor[T,sup,sub],t]+
          
          ChristoffelTerms[{x,g,\[CapitalGamma]},Tensor[T,sup,sub],CovInd,a,
              indt]*TotalD[Tensor[x,{a},{Void}],t]
        ]/;!VectorQ[t];

ExpandAbsoluteD[{x_,\[Delta]_,g_,\[CapitalGamma]_},dummy_][   
    AbsoluteD[Tensor[T_,sup_,sub_] ,t_]]:=
  Module[{dct},
      dct=MapThread[Append,{dummy,t}];
      Fold[
          ExpandAbsoluteDXX[{x,\[Delta],g,\[CapitalGamma]}]  
          ,{Tensor[T,sup,sub],sup,sub}
          ,dct]\[LeftDoubleBracket]1\[RightDoubleBracket]
      ]/;VectorQ[t]



ExpandAbsoluteDXX[{x_,\[Delta]_,g_,\[CapitalGamma]_}][{T_,sup_,sub_},{Dummy_,
        CovInd_,t_}]:=
    Module[{indT},
      indT=Transpose[{sup,sub}];
      { TotalD[T,t]+
          ChristoffelTerms[{x,g,\[CapitalGamma]},T,CovInd,Dummy,indT]*
            TotalD[Tensor[x,{Dummy},{Void}],t],sup,sub}];



ExpandAbsoluteD[_,_][HoldPattern[totd:TotalD[_,_]]]:=totd



LieD[T_Plus,V_] := Map[ LieD[#,V]& , T ];

LieD[u_?NumericQ,__]:=0;

LieD[u_Symbol,_]:=0;

LieD[w_Plus,V_]:=(LieD[#1,V]&)/@w;

LieD[w_*u_,V_]:=LieD[w,V] *u+LieD[u,V]* w/;Not[VectorQ[V]];



LieD[w_*u_,V_List]:=Fold[  LieD[#1,#2]&,w*u,V];

LieD[   LieD[T_ , U_] , V_ ]:=LieD[   T ,   Flatten[{U,V}]  ];

LieD[T_ ,U_List]:=Fold[  LieD[  #1 ,#2 ]& ,T,U]/;Head[T]=!=Tensor;





ExpandLieD[args__][
    expr_/;MemberQ[{List,Equal,Plus,Less,Greater,LessEqual,GreaterEqual}, 
        Head[expr]]]:=ExpandLieD[args]/@expr



LieDOrderMatchQ[expr_,dummies_]:=
  Module[{work,orderexpr,orderdummies=Length[Flatten[{dummies}]]},
    work=expr/.a_+b__/;FreeQ[a, LieD]\[And]FreeQ[b, LieD]\[Rule]1;
    If[\[Not]FreeQ[work, Plus,{0,1}],Return[False]];
    orderexpr=Length[Flatten[Cases[work, LieD[_,t_]\[RuleDelayed]t,{0,1}]]];
    orderexpr\[Equal]orderdummies
    ]



ExpandLieD[_,dummies_][expr_]/;\[Not]LieDOrderMatchQ[expr,dummies]:=expr;

ExpandLieD[x_,dummy_][T_?NumericQ*V_]:=T* ExpandLieD[x,dummy][V];

ExpandLieD[x_,dummy_][T_*V_]:=T* ExpandLieD[x,dummy][V]/;FreeLieDQ[T];

ExpandLieD[x_,dummy_][T_]:=T/;FreeLieDQ[T];

ExpandLieD[x_,{dummy1_,dummy2__}][T_*V_]:=
    ExpandLieD[x,dummy1][T]*ExpandLieD[x,{dummy2}][V]/;
      Not[FreeLieDQ[T]]&&Not[FreeLieDQ[V]];

ExpandLieD[x_,{a_}][T_]:=ExpandLieD[x,a][T];



PartialDFieldV[{x_,\[Delta]_,g_,\[CapitalGamma]_},V_,dummy_][{i_,
        Void}]:=-PartialD[{x,\[Delta],g,\[CapitalGamma]}][  
        Tensor[V,{i},{Void}],Tensor[x,{dummy},{Void}]];

PartialDFieldV[{x_,\[Delta]_,g_,\[CapitalGamma]_},V_,dummy_][{Void,i_}]:=
    PartialD[{x,\[Delta],g,\[CapitalGamma]}][   Tensor[V,{dummy},{Void}],
      Tensor[x,{i},{Void}]];

ExpandLieD[{x_,\[Delta]_,g_,\[CapitalGamma]_},dummy_][      
    LieD[Tensor[T_,sup_,sub_],V_]    ]:=Module[{indT},
      indT=Transpose[{sup,sub}];
      PartialD[{x,\[Delta],g,\[CapitalGamma]}][Tensor[T,sup,sub],
            Tensor[x,{dummy},{Void}]]*Tensor[V,{dummy},{Void}]+
        Map[ChangeIndexToDummy[Tensor[T,sup,sub],#,dummy]& ,  indT].
          Map[PartialDFieldV[{x,\[Delta],g,\[CapitalGamma]},V,dummy],indT]
      
      ]/;Not[VectorQ[V]]

ExpandLieD[{x_,\[Delta]_,g_,\[CapitalGamma]_},dummy_][      
    LieD[Tensor[T_,sup_,sub_],V_]    ]:=Module[{indT,dumV},
      indT=Transpose[{sup,sub}];
      dumV=Transpose[{dummy,V}];
      
      Fold[
        Function[{Tens,dummyV},
          
          PartialD[{x,\[Delta],g,\[CapitalGamma]}][ Tens,
                Tensor[x,{dummyV\[LeftDoubleBracket]1\[RightDoubleBracket]},{\
Void}] ]*Tensor[
                dummyV\[LeftDoubleBracket]2\[RightDoubleBracket],{dummyV\
\[LeftDoubleBracket]1\[RightDoubleBracket]},{Void}]+
            
            Map[ChangeIndexToDummy[Tens,#,
                    dummyV\[LeftDoubleBracket]1\[RightDoubleBracket]]& ,  
                indT].
              
              Map[PartialDFieldV[{x,\[Delta],g,\[CapitalGamma]},
                  dummyV\[LeftDoubleBracket]2\[RightDoubleBracket],
                  dummyV\[LeftDoubleBracket]1\[RightDoubleBracket]],indT]],
        Tensor[T,sup,sub],dumV]
      ]/;VectorQ[V]

ExpandLieD[{x_,\[Delta]_,g_,\[CapitalGamma]_},dummy_][      
    LieD[Tensor[\[Phi]_],V_]    ]:=Module[{},
      PartialD[{x,\[Delta],g,\[CapitalGamma]}][ Tensor[\[Phi]],
          Tensor[x,{dummy},{Void}] ]*Tensor[V,{dummy},{Void}]
      ]/;Not[VectorQ[V]]

ExpandLieD[{x_,\[Delta]_,g_,\[CapitalGamma]_},dummy_][      
    LieD[Tensor[\[Phi]_],V_]    ]:=Module[{dumV},
      dumV=Transpose[{dummy,V}];
      Fold[
        Function[{Tens,dummyV},
          
          PartialD[{x,\[Delta],g,\[CapitalGamma]}][ Tens,
              Tensor[x,{dummyV\[LeftDoubleBracket]1\[RightDoubleBracket]},{\
Void} ]]*Tensor[
              dummyV\[LeftDoubleBracket]2\[RightDoubleBracket],{dummyV\
\[LeftDoubleBracket]1\[RightDoubleBracket]},{Void}]],Tensor[\[Phi]],dumV]
      ]/;VectorQ[V]



FreeTensorQ[w_]:= Position[w,Tensor]=={};

FreeCovQ[w_]:= Position[w,Cov]=={};

FreeTotalDQ[w_]:= Position[w,TotalD]=={};

FreeAbsoluteDQ[w_]:= Position[w,AbsoluteD]=={};

FreeLieDQ[w_]:= Position[w,LieD]=={};



End[]



DeclareBaseIndices[{1,2,3}];

IndexFlavors={};

PatternSymmetries={};

SetDerivativeSymbols[{",",";","\[DifferentialD]","\[DifferentialD]","D","d",
    ""}]

Off[General::spell]
Off[General::spell1];

EndPackage[]