(************** Content-type: application/mathematica **************
                     CreatedBy='Mathematica 4.2'

                    Mathematica-Compatible Notebook

This notebook can be used with any Mathematica-compatible
application, such as Mathematica, MathReader or Publicon. The data
for the notebook starts with the line containing stars above.

To get the notebook into a Mathematica-compatible application, do
one of the following:

* Save the data starting with the line of stars above into a file
  with a name ending in .nb, then open the file inside the
  application;

* Copy the data starting with the line of stars above to the
  clipboard, then use the Paste menu command inside the application.

Data for notebooks contains only printable 7-bit ASCII and can be
sent directly in email or through ftp in text mode.  Newlines can be
CR, LF or CRLF (Unix, Macintosh or MS-DOS style).

NOTE: If you modify the data for this notebook not in a Mathematica-
compatible application, you must delete the line below containing
the word CacheID, otherwise Mathematica-compatible applications may
try to use invalid cache data.

For more information on notebooks and Mathematica-compatible 
applications, contact Wolfram Research:
  web: http://www.wolfram.com
  email: info@wolfram.com
  phone: +1-217-398-0700 (U.S.)

Notebook reader applications are available free of charge from 
Wolfram Research.
*******************************************************************)

(*CacheID: 232*)


(*NotebookFileLineBreakTest
NotebookFileLineBreakTest*)
(*NotebookOptionsPosition[     34700,       1045]*)
(*NotebookOutlinePosition[     35453,       1071]*)
(*  CellTagsIndexPosition[     35409,       1067]*)
(*WindowFrame->Normal*)



Notebook[{

Cell[CellGroupData[{
Cell["The Lorentz Transformation", "Title"],

Cell[TextData[{
  "Box 2.4 & Section 2.9, Lorentz Transformation from\nMisner, Thorne & \
Wheeler, ",
  StyleBox["Gravitation",
    FontSlant->"Italic"]
}], "Chaptertitle"],

Cell["\<\
David Park
djmp@earthlink.net\
\>", "Subsubtitle"],

Cell[TextData[{
  "This notebook defines routines, ",
  Cell[BoxData[
      \(LorentzMatrixRules\)]],
  " and ",
  Cell[BoxData[
      \(LorentzMatrixValues\)]],
  " that calculate and store the values for the Lorentz transformation \
matrix. They are then used to solve some simple special relativity problems."
}], "Text"],

Cell["\<\
All the necessary initializations will be automatically performed. You can \
begin with the Examples section.\
\>", "Text"],

Cell[CellGroupData[{

Cell["Initialization", "Section"],

Cell[BoxData[
    \(Needs["\<TensorCalculus3`Tensorial`\>"]\)], "Input",
  InitializationCell->True],

Cell["\<\
Special relativity coordinates and red flavor for a boosted frame.\
\>", "Text"],

Cell[BoxData[{
    \(DeclareBaseIndices[{0, 1, 2, 3}]\), "\[IndentingNewLine]", 
    \(DeclareIndexFlavor[{red, Red}, {green, CinnabarGreen}]\)}], "Input",
  InitializationCell->True],

Cell["Metric for Minkowski spacetime.", "Text"],

Cell[BoxData[{
    \(DefineTensorShortcuts[\[Eta], 2]\), "\[IndentingNewLine]", 
    \(SetTensorValues[\[Eta]dd[i, j], 
      DiagonalMatrix[{\(-1\), 1, 1, 1}]]\), "\[IndentingNewLine]", 
    \(SetTensorValues[\[Eta]dd[i, j] // ToFlavor[red], 
      DiagonalMatrix[{\(-1\), 1, 1, 1}]]\)}], "Input",
  InitializationCell->True],

Cell["Coordinates, displacements, 4-velocity and basis vectors.", "Text"],

Cell[BoxData[
    \(DefineTensorShortcuts[{x, dx, u, e}, 1]\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["LorentzMatrixRules & LorentzMatrixValues Routines", "Section"],

Cell[BoxData[{\(ClearAll[LorentzMatrixRules];\), "\[IndentingNewLine]", 
    RowBox[{\(LorentzMatrixRules::usage = "\<LorentzMatrixRules[\
\[CapitalLambda], newflavor, oldflavor][\[Beta], \[Phi], \[Theta]] will \
generate and store the component rules of the Lorentz transformation matrix \
to a frame moving with the velocity \[Beta] in the spherical direction \[Phi] \
(angle from xy-plane) and \[Theta] (rotation from x axis about z axis). The \
components will be stored under the label \[CapitalLambda] with the upper \
index in the newflavor and the lower index in the restflavor. Identity can be \
used as the flavor for plain indices. The values are stored as \
TensorValueRules[\[CapitalLambda]]. The inverse values are also stored.\>";\),
       "\[IndentingNewLine]"}], "\[IndentingNewLine]", 
    RowBox[{\(\(LorentzMatrixRules[\[CapitalLambda]_, newflavor_, 
          oldflavor_:  Identity]\)[\[Beta]_ /; 
          If[NumericQ[\[Beta]], Abs[\[Beta]] < 1, 
            True], \[Phi]_, \[Theta]_]\), ":=", "\[IndentingNewLine]", 
      RowBox[{"Module", "[", "\[IndentingNewLine]", 
        RowBox[{\({\[Gamma] = 1/\@\(1 - \[Beta]\^2\), \[IndentingNewLine]n1, 
            n2, n3, \[Alpha], \[Gamma]1, matrix}\), ",", 
          "\[IndentingNewLine]", 
          
          RowBox[{\(DefineTensorShortcuts[\[CapitalLambda], 2]\), ";", 
            "\[IndentingNewLine]", \({n1, n2, 
                n3} = {Cos[\[Phi]] Cos[\[Theta]], Cos[\[Phi]] Sin[\[Theta]], 
                Sin[\[Phi]]}\), ";", 
            "\[IndentingNewLine]", \(\[Gamma]1 = \[Gamma] - 1\), ";", 
            "\[IndentingNewLine]", 
            RowBox[{"matrix", "=", 
              RowBox[{"(", GridBox[{
                    {
                      "\[Gamma]", \(\(-\[Alpha]\)\ \[Gamma]\ n1\), \(\(-\
\[Alpha]\)\ \[Gamma]\ n2\), \(\(-\[Alpha]\)\ \[Gamma]\ n3\)},
                    {\(\(-\[Alpha]\)\ \[Gamma]\ n1\), \(1 + \[Gamma]1\ n1\ n1\
\), \(\[Gamma]1\ n1\ n2\), \(\[Gamma]1\ n1\ n3\)},
                    {\(\(-\[Alpha]\)\ \[Gamma]\ n2\), \(\[Gamma]1\ n2\ n1\), \
\(1 + \[Gamma]1\ n2\ n2\), \(\[Gamma]1\ n2\ n3\)},
                    {\(\(-\[Alpha]\)\ \[Gamma]\ n3\), \(\[Gamma]1\ n3\ n1\), \
\(\[Gamma]1\ n3\ n2\), \(1 + \[Gamma]1\ n3\ n3\)}
                    }], ")"}]}], ";", 
            "\[IndentingNewLine]", \(SetTensorValueRules[\[CapitalLambda]ud[
                newflavor@i, oldflavor@j], \ 
              matrix /. \[Alpha] \[Rule] \[Beta]]\), ";", 
            "\[IndentingNewLine]", \(SetTensorValueRules[\[CapitalLambda]ud[
                oldflavor@i, newflavor@j], \ 
              matrix /. \[Alpha] \[Rule] \(-\[Beta]\)]\), ";"}]}], 
        "\[IndentingNewLine]", "]"}]}]}], "Input",
  InitializationCell->True],

Cell[BoxData[{\(ClearAll[LorentzMatrixValues];\), "\[IndentingNewLine]", 
    RowBox[{\(LorentzMatrixValues::usage = "\<LorentzMatrixValues[\
\[CapitalLambda], newflavor, oldflavor][\[Beta], \[Phi], \[Theta]] will \
generate and store the component values of the Lorentz transformation matrix \
to a frame moving with the velocity \[Beta] in the spherical direction \[Phi] \
(angle from xy-plane) and \[Theta] (rotation from x axis about z axis). The \
components will be stored under the label \[CapitalLambda] with the upper \
index in the newflavor and the lower index in the restflavor. Identity can be \
used as the flavor for plain indices. The values are stored as \
TensorValueRules[\[CapitalLambda]]. The inverse values are also stored.\>";\),
       "\[IndentingNewLine]"}], "\[IndentingNewLine]", 
    RowBox[{\(\(LorentzMatrixValues[\[CapitalLambda]_, newflavor_, 
          oldflavor_:  Identity]\)[\[Beta]_ /; 
          If[NumericQ[\[Beta]], Abs[\[Beta]] < 1, 
            True], \[Phi]_, \[Theta]_]\), ":=", "\[IndentingNewLine]", 
      RowBox[{"Module", "[", "\[IndentingNewLine]", 
        RowBox[{\({\[Gamma] = 1/\@\(1 - \[Beta]\^2\), \[IndentingNewLine]n1, 
            n2, n3, \[Alpha], \[Gamma]1, matrix}\), ",", 
          "\[IndentingNewLine]", 
          
          RowBox[{\(DefineTensorShortcuts[\[CapitalLambda], 2]\), ";", 
            "\[IndentingNewLine]", \({n1, n2, 
                n3} = {Cos[\[Phi]] Cos[\[Theta]], Cos[\[Phi]] Sin[\[Theta]], 
                Sin[\[Phi]]}\), ";", 
            "\[IndentingNewLine]", \(\[Gamma]1 = \[Gamma] - 1\), ";", 
            "\[IndentingNewLine]", 
            RowBox[{"matrix", "=", 
              RowBox[{"(", GridBox[{
                    {
                      "\[Gamma]", \(\(-\[Alpha]\)\ \[Gamma]\ n1\), \(\(-\
\[Alpha]\)\ \[Gamma]\ n2\), \(\(-\[Alpha]\)\ \[Gamma]\ n3\)},
                    {\(\(-\[Alpha]\)\ \[Gamma]\ n1\), \(1 + \[Gamma]1\ n1\ n1\
\), \(\[Gamma]1\ n1\ n2\), \(\[Gamma]1\ n1\ n3\)},
                    {\(\(-\[Alpha]\)\ \[Gamma]\ n2\), \(\[Gamma]1\ n2\ n1\), \
\(1 + \[Gamma]1\ n2\ n2\), \(\[Gamma]1\ n2\ n3\)},
                    {\(\(-\[Alpha]\)\ \[Gamma]\ n3\), \(\[Gamma]1\ n3\ n1\), \
\(\[Gamma]1\ n3\ n2\), \(1 + \[Gamma]1\ n3\ n3\)}
                    }], ")"}]}], ";", 
            "\[IndentingNewLine]", \(SetTensorValues[\[CapitalLambda]ud[
                newflavor@i, oldflavor@j], \ 
              matrix /. \[Alpha] \[Rule] \[Beta]]\), ";", 
            "\[IndentingNewLine]", \(SetTensorValues[\[CapitalLambda]ud[
                oldflavor@i, newflavor@j], \ 
              matrix /. \[Alpha] \[Rule] \(-\[Beta]\)]\), ";"}]}], 
        "\[IndentingNewLine]", "]"}]}]}], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Examples", "Section"],

Cell[CellGroupData[{

Cell["Lorentz transformations for boosts in various directions", "Subsection"],

Cell[BoxData[
    \(\(?LorentzMatrixValues\)\)], "Input"],

Cell["A boost in the x direction...", "Text"],

Cell[BoxData[{
    \(\(LorentzMatrixValues[\[CapitalLambda], red]\)[\[Beta], 0, 
      0]\), "\[IndentingNewLine]", 
    \(\[CapitalLambda]ud[red@i, j]\), "\[IndentingNewLine]", 
    \(% // EinsteinArray[]\)}], "Input"],

Cell["Restricting to a 2-dimensional expansion...", "Text"],

Cell[BoxData[{
    \(\[CapitalLambda]ud[red@i, j]\), "\[IndentingNewLine]", 
    \(% // EinsteinArray[{0, 1}]\)}], "Input"],

Cell["The inverse transformation...", "Text"],

Cell[BoxData[{
    \(\[CapitalLambda]ud[i, red@j]\), "\[IndentingNewLine]", 
    \(% // EinsteinArray[{0, 1}]\)}], "Input"],

Cell["A boost in the y direction...", "Text"],

Cell[BoxData[{
    \(\(LorentzMatrixValues[\[CapitalLambda], red]\)[\[Beta], 
      0, \[Pi]/2]\), "\[IndentingNewLine]", 
    \(\[CapitalLambda]ud[red@i, j]\), "\[IndentingNewLine]", 
    \(% // EinsteinArray[]\)}], "Input"],

Cell["A boost in the z direction...", "Text"],

Cell[BoxData[{
    \(\(LorentzMatrixValues[\[CapitalLambda], red]\)[\[Beta], \[Pi]/2, 
      0]\), "\[IndentingNewLine]", 
    \(\[CapitalLambda]ud[red@i, j]\), "\[IndentingNewLine]", 
    \(% // EinsteinArray[]\)}], "Input"],

Cell["A boost in an arbitrary direction...", "Text"],

Cell[BoxData[{
    \(\(LorentzMatrixValues[\[CapitalLambda], 
        red]\)[\[Beta], \[Phi], \[Theta]]\), "\[IndentingNewLine]", 
    \(\[CapitalLambda]ud[red@i, j]\), "\[IndentingNewLine]", 
    \(% // EinsteinArray[]\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Transformation of Coordinates", "Subsection"],

Cell["\<\
Transforming to the red frame for a boost in the x direction...\
\>", "Text"],

Cell[BoxData[{
    \(\(LorentzMatrixValues[\[CapitalLambda], red]\)[\[Beta], 0, 
      0]\), "\[IndentingNewLine]", 
    \(xu[red@i] == \[CapitalLambda]ud[red@i, j] 
        xu[j]\), "\[IndentingNewLine]", 
    \(\(% // ToArrayValues[]\) // TableForm\)}], "Input"],

Cell["For a general boost...", "Text"],

Cell[BoxData[{
    \(\(LorentzMatrixValues[\[CapitalLambda], 
        red]\)[\[Beta], \[Phi], \[Theta]]\), "\[IndentingNewLine]", 
    \(xu[red@i] == \[CapitalLambda]ud[red@i, j] 
        xu[j]\), "\[IndentingNewLine]", 
    \(\(% // ToArrayValues[]\) // TableForm\)}], "Input"],

Cell[TextData[{
  "Take an event to occur at ",
  Cell[BoxData[
      \(1\)]],
  " unit of time in the plain frame. Let ",
  Cell[BoxData[
      \(\[Beta] \[Equal] 0.5\)]],
  " and let the red frame boost be half way between the x and y directions. \
Calculate the coordinates of the event in the red frame."
}], "Text"],

Cell[BoxData[{
    \(SetTensorValues[xu[i], {1, 0, 0, 0}]\), "\[IndentingNewLine]", 
    \(\(LorentzMatrixValues[\[CapitalLambda], red]\)[0.5, 
      0, \[Pi]/4]\), "\[IndentingNewLine]", 
    \(xu[red@i] == \[CapitalLambda]ud[red@i, j] 
        xu[j]\), "\[IndentingNewLine]", 
    \(\(% // ToArrayValues[]\) // TableForm\)}], "Input"],

Cell[TextData[{
  "Take an event to occur at ",
  Cell[BoxData["1"]],
  " unit of time in the red frame. Let ",
  Cell[BoxData[
      RowBox[{"\[Beta]", "\[Equal]", "0.5"}]]],
  " and let the red frame boost be half way between the x and y directions. \
Calculate the coordinates of the event in the plain frame. The LorentzMatrix \
routines calculate and store values for both the direct and reverse \
transformations."
}], "Text"],

Cell[BoxData[{
    \(ClearTensorValues[xu[i]]\), "\[IndentingNewLine]", 
    \(SetTensorValues[xu[red@i], {1, 0, 0, 0}]\), "\[IndentingNewLine]", 
    \(\(LorentzMatrixValues[\[CapitalLambda], red]\)[0.5, 
      0, \[Pi]/4]\), "\[IndentingNewLine]", 
    \(xu[i] == \[CapitalLambda]ud[i, red@j] 
        xu[red@j]\), "\[IndentingNewLine]", 
    \(\(% // ToArrayValues[]\) // TableForm\), "\[IndentingNewLine]", 
    \(ClearTensorValues[xu[red@i]]\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Checking the Inverse Transformation", "Subsection"],

Cell["\<\
The direct and reverse Lorentz transformation matrices should be inverse \
matrices. Define the general boost...\
\>", "Text"],

Cell[BoxData[
    \(\(LorentzMatrixValues[\[CapitalLambda], 
        red]\)[\[Beta], \[Phi], \[Theta]]\)], "Input"],

Cell[BoxData[{
    \(\[CapitalLambda]ud[red@\[Alpha], \[Beta]] \[CapitalLambda]ud[\[Beta], 
        red@\[Gamma]]\), "\[IndentingNewLine]", 
    \(\(% // ToArrayValues[]\) // Simplify\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Transformation of Basis Vectors", "Subsection"],

Cell["\<\
We can obtain the transformation for the basis vectors, e, by using the fact \
that the 4-velocity, u, is an invariant.\
\>", "Text"],

Cell[BoxData[
    \(\(LorentzMatrixValues[\[CapitalLambda], 
        red]\)[\[Beta], \[Phi], \[Theta]]\)], "Input"],

Cell[BoxData[{
    \(xu[j] 
        ed[j] == \((xu[i] ed[i] // 
          ToFlavor[red])\)\), "\[IndentingNewLine]", 
    \(% /. xu[red@i] \[Rule] \[CapitalLambda]ud[red@i, j] 
          xu[j]\), "\[IndentingNewLine]", 
    \(\(#/xu[j] &\) /@ %\)}], "Input"],

Cell["And for the inverse transformation...", "Text"],

Cell[BoxData[{
    \(\((xu[j] ed[j] // ToFlavor[red])\) == 
      xu[i] ed[i]\), "\[IndentingNewLine]", 
    \(% /. xu[i] \[Rule] \[CapitalLambda]ud[i, red@j] 
          xu[red@j]\), "\[IndentingNewLine]", 
    \(\(#/xu[red@j] &\) /@ %\)}], "Input"],

Cell[TextData[{
  "Note that the transformations are always up/down, and they should always \
have two different index flavors.  To do a transformation we simply match up \
the colors and positions of the indices to obtain a consistent set of \
indices. Also, we will use one ",
  Cell[BoxData["\[CapitalLambda]"]],
  " matrix for each index that is transformed."
}], "Text"],

Cell[TextData[{
  "As an example, let's calculate the rest frame basis vectors that \
correspond to an orthonormal red frame. Let the red frame be moving with \
speed ",
  Cell[BoxData[
      RowBox[{"\[Beta]", "\[Equal]", "0.5"}]]],
  " along the positive x axis."
}], "Text"],

Cell[BoxData[{
    \(\(LorentzMatrixValues[\[CapitalLambda], red]\)[0.5, 0, 
      0]\), "\[IndentingNewLine]", 
    \(SetTensorValues[ed[red@i], 
      IdentityMatrix[4]]\), "\[IndentingNewLine]", 
    \(ed[i] \[Equal] \[CapitalLambda]ud[red@j, i] 
        ed[red@j]\), "\[IndentingNewLine]", 
    \(% // EinsteinSum[]\), "\[IndentingNewLine]", 
    \(\(% // EinsteinArray[]\) // TableForm\), "\[IndentingNewLine]", 
    \(ClearTensorValues[ed[red@i]]\)}], "Input"],

Cell["\<\
The way that EinsteinSum worked here may at first seem a little shocking. But \
remember that the basis vectors were given vector values and the rhs is a sum \
of vectors. Conversely, let's take an orthonormal plain frame and calculate \
the corresponding basis vectors in the red frame.\
\>", "Text"],

Cell[BoxData[{
    \(\(LorentzMatrixValues[\[CapitalLambda], red]\)[0.5, 0, 
      0]\), "\[IndentingNewLine]", 
    \(SetTensorValues[ed[i], IdentityMatrix[4]]\), "\[IndentingNewLine]", 
    \(ed[red@i] \[Equal] \[CapitalLambda]ud[j, red@i] 
        ed[j]\), "\[IndentingNewLine]", 
    \(% // EinsteinSum[]\), "\[IndentingNewLine]", 
    \(\(% // EinsteinArray[]\) // TableForm\), "\[IndentingNewLine]", 
    \(ClearTensorValues[ed[i]]\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "Invariant Spacetime Intervals,\nInvariant Spacetime Mertic,\n",
  Cell[BoxData[
      RowBox[{
        RowBox[{
          RowBox[{"Transpose", "[", "\[CapitalLambda]", "]"}], ".", "\[Eta]", 
          ".", "\[CapitalLambda]"}], "\[Equal]", "\[Eta]"}]]]
}], "Subsection"],

Cell["\<\
Generate a boost in an arbitrary direction. These are the Lorentz \
transformation and Minkowski metric matrices...\
\>", "Text"],

Cell[BoxData[{
    \(\(LorentzMatrixValues[\[CapitalLambda], red, 
        Identity]\)[\[Beta], \[Phi], \[Theta]]\), "\n", 
    \(\[CapitalLambda]ud[red@i, j]\), "\n", 
    \(\[Lambda]mat = % // EinsteinArray[]\)}], "Input"],

Cell[BoxData[{
    \(\[Eta]dd[i, j]\), "\[IndentingNewLine]", 
    \(\[Eta]mat = % // EinsteinArray[]\)}], "Input"],

Cell["\<\
The Lorentz transfornation matrix and the Minkowski metric satisfy the \
following matrix identity.\
\>", "Text"],

Cell[BoxData[{
    \(HoldForm[
      Transpose[\[Lambda]mat] . \[Eta]mat . \[Lambda]mat == \[Eta]mat]\), "\
\[IndentingNewLine]", 
    \(\(% // ReleaseHold\) // Simplify\)}], "Input"],

Cell[TextData[{
  "What this means is that the flat spacetime metric is invariant to boosts. \
Let's do a conventional transformation of the Minkowski metric to the frame \
boosted in an arbitrary direction. (We set the values of ",
  Cell[BoxData[
      \(\[Eta]\)]],
  " in both frames in the initialization.)"
}], "Text"],

Cell[BoxData[{
    \(\((\[Eta]dd[\[Alpha], \[Beta]] // 
          ToFlavor[red])\) == \[CapitalLambda]ud[\[Mu], 
          red@\[Alpha]] \[CapitalLambda]ud[\[Nu], 
          red@\[Beta]] \[Eta]dd[\[Mu], \[Nu]]\), "\[IndentingNewLine]", 
    \(\(% // ToArrayValues[]\) // Simplify\)}], "Input"],

Cell["\<\
All inertial observers see the same spacetime structure. This means in turn \
that spacetime intervals as measured by two inertial observers are invariant. \
Set the Minkowski metric in the red frame.\
\>", "Text"],

Cell["\<\
Equate the spacetime intervals in the two frames. Then calculate the \
displacements in the red frame in terms of the displacements in the plain \
frame using the Lorentz transformation. Expanding the sums shows that they \
are equal.\
\>", "Text"],

Cell[BoxData[{
    \(\((\[Eta]dd[\[Alpha], \[Beta]] dxu[\[Alpha]] dxu[\[Beta]] // 
          ToFlavor[red])\) == \[Eta]dd[\[Mu], \[Nu]] dxu[\[Mu]] 
        dxu[\[Nu]]\), "\[IndentingNewLine]", 
    \(% /. {dxu[red@\[Alpha]] \[Rule] \[CapitalLambda]ud[red@\[Alpha], \[Mu]] 
            dxu[\[Mu]], 
        dxu[red@\[Beta]] \[Rule] \[CapitalLambda]ud[red@\[Beta], \[Nu]] 
            dxu[\[Nu]]}\), "\[IndentingNewLine]", 
    \(\(% // EinsteinSum[]\) // Simplify\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Motion along x axis.", "Subsection"],

Cell["\<\
A particle (red frame) is moving along the x axis at speed \[Beta].  We mark \
the event at 1 unit of time on the particle's trajectory.\
\>", "Text"],

Cell[BoxData[
    \(\(LorentzMatrixValues[\[CapitalLambda], red, Identity]\)[\[Beta], 0, 
      0]\)], "Input"],

Cell[BoxData[
    \(SetTensorValues[xu[red@i], {1, 0, 0, 0}]\)], "Input"],

Cell["\<\
We calculate the components of the event in the rest frame. We take just the \
t and x components since the others are zero.\
\>", "Text"],

Cell[BoxData[{
    \(\[CapitalLambda]ud[i, red@j] xu[red@j]\), "\[IndentingNewLine]", 
    \(step1 = \(% // EinsteinSum[]\) // EinsteinArray[{0, 1}]\)}], "Input"],

Cell["\<\
The velocity of the particle as measured in the rest frame is just x/t \
or...\
\>", "Text"],

Cell[BoxData[
    \(Divide @@ Reverse[step1]\)], "Input"],

Cell["...as expected.", "Text"],

Cell["\<\
If the particle is moving at half the speed of light, the coordinates of the \
event in the rest frame are...\
\>", "Text"],

Cell[BoxData[
    \(step1 /. \[Beta] \[Rule] 0.5\)], "Input"],

Cell[TextData[{
  "We think the particle's clock is running slow since when it reads ",
  Cell[BoxData["1"]],
  " unit of time, we measure ",
  Cell[BoxData["1.1547"]],
  " units of time."
}], "Text"],

Cell[TextData[{
  "Conversely, if we set the spacetime event to be us at ",
  Cell[BoxData["1"]],
  " unit of time..."
}], "Text"],

Cell[BoxData[
    \(SetTensorValues[xu[i], {1, 0, 0, 0}]\)], "Input"],

Cell["then in the red frame this has coordinates...", "Text"],

Cell[BoxData[{
    \(\[CapitalLambda]ud[red@i, j] xu[j]\), "\[IndentingNewLine]", 
    \(step2 = \(% // EinsteinSum[]\) // 
        EinsteinArray[{0, 1}]\), "\[IndentingNewLine]", 
    \(% /. \[Beta] \[Rule] 0.5\)}], "Input"],

Cell["\<\
By the particle's clock, our clock is running slow. The particle sees our \
speed as...\
\>", "Text"],

Cell[BoxData[
    \(Divide @@ Reverse[step2]\)], "Input"],

Cell[TextData[{
  "For length contraction: Let a rod have unit length and be moving with \
speed \[Beta]. When the back end is at the origin the lab simultaneously \
measures the location of the front end as ",
  Cell[BoxData[
      \(l\)]],
  ". But in the rod frame, the two events are not simutaneous. (That's the \
letter ",
  Cell[BoxData[
      \(l\)]],
  " for length above and in the following.)"
}], "Text"],

Cell[BoxData[{
    \(SetTensorValues[xu[i], {0, l, 0, 0}]\), "\n", 
    \(SetTensorValues[xu[red@i], {t, 1, 0, 0}]\)}], "Input"],

Cell[TextData[{
  "Equating the rod frame components to the transformation of the rest frame \
event, solving for t in the rod frame and l in the rest frame, and evaluating \
for ",
  Cell[BoxData[
      RowBox[{"\[Beta]", "\[Equal]", "0.5"}]]],
  "..."
}], "Text"],

Cell[BoxData[{
    \(xu[red@i] == \[CapitalLambda]ud[red@i, j] 
        xu[j]\), "\[IndentingNewLine]", 
    \(\(% // EinsteinSum[]\) // 
      EinsteinArray[{0, 1}]\), "\[IndentingNewLine]", 
    \(\(Solve[%, {l, t}]\)\_\(\(\[LeftDoubleBracket]\)\(1\)\(\
\[RightDoubleBracket]\)\)\), "\[IndentingNewLine]", 
    \(% /. \[Beta] \[Rule] 0.5\)}], "Input"],

Cell["\<\
The lab frame sees the rod as shortened, but by the rod clock the front end \
was measured half a unit of time earlier than the back end.\
\>", "Text"],

Cell[BoxData[
    \(\(ClearTensorValues /@ {xu[i], xu[red@i]};\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Combination of Two Boosts in the Same Direction", "Subsection"],

Cell["Define two boosts in the x direction.", "Text"],

Cell[BoxData[{
    \(\(LorentzMatrixValues[\[CapitalLambda], red]\)[\[Beta]1, 0, 
      0]\), "\[IndentingNewLine]", 
    \(\(LorentzMatrixValues[\[CapitalLambda], green, red]\)[\[Beta]2, 0, 
      0]\)}], "Input"],

Cell[TextData[{
  "Take the event to occur at ",
  Cell[BoxData["1"]],
  " unit of time in the green frame."
}], "Text"],

Cell[BoxData[
    \(SetTensorValues[xu[green@i], {1, 0, 0, 0}]\)], "Input"],

Cell["\<\
Calculate the coordinates in the red frame and store them. Then calculate the \
coordinates in the plain frame.\
\>", "Text"],

Cell[BoxData[{
    \(\[CapitalLambda]ud[red@i, green@j] 
      xu[green@j]\), "\[IndentingNewLine]", 
    \(step1 = % // ToArrayValues[]\), "\[IndentingNewLine]", 
    \(SetTensorValues[xu[red@i], %]\), "\[IndentingNewLine]", 
    \(\[CapitalLambda]ud[i, red@j] xu[red@j]\), "\[IndentingNewLine]", 
    \(step2 = \(% // ToArrayValues[]\) // Simplify\)}], "Input"],

Cell["The red frame sees the green frame moving at the speed...", "Text"],

Cell[BoxData[
    \(Divide @@ Reverse[Take[step1, 2]]\)], "Input"],

Cell["The plain frame sees the green frame moving at the speed...", "Text"],

Cell[BoxData[
    \(Divide @@ Reverse[Take[step2, 2]] // Simplify\)], "Input"],

Cell["Or we can do the calculation in one step...", "Text"],

Cell[BoxData[{
    \(\[CapitalLambda]ud[i, red@j] \[CapitalLambda]ud[red@j, green@k] 
      xu[green@k]\), "\[IndentingNewLine]", 
    \(\(\(% // EinsteinSum[]\) // EinsteinArray[{0, 1}]\) // 
      Simplify\), "\[IndentingNewLine]", 
    \(Divide @@ Reverse[%]\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Aberration of Starlight - MTW Calculation", "Subsection"],

Cell["\<\
We are observing a star from the red frame moving in the positive x \
direction...\
\>", "Text"],

Cell[BoxData[
    \(\(LorentzMatrixValues[\[CapitalLambda], red]\)[\[Beta], 0, 
      0]\)], "Input"],

Cell[TextData[{
  "In the rest frame, with respect to the star, we specify an event on the \
past light cone in the direction of the star. ",
  Cell[BoxData["\[Theta]"]],
  " is the angle above the xy-plane."
}], "Text"],

Cell[BoxData[
    \(SetTensorValues[
      xu[i], {\(-1\), Cos[\[Theta]], 0, Sin[\[Theta]]}]\)], "Input"],

Cell["We can check that this is on the light cone...", "Text"],

Cell[BoxData[{
    \(\[Eta]dd[i, j] xu[i] xu[j]\), "\[IndentingNewLine]", 
    \(\(% // EinsteinSum[]\) // Simplify\)}], "Input"],

Cell["Transforming the event to the moving red frame...", "Text"],

Cell[BoxData[{
    \(\[CapitalLambda]ud[red@i, j] xu[j]\), "\[IndentingNewLine]", 
    \(% // EinsteinSum[]\), "\[IndentingNewLine]", 
    \({tred, xred, yred, zred} = \(% // EinsteinArray[]\) // 
        Simplify\), "\[IndentingNewLine]", 
    \(SetTensorValues[xu[red@i], %]\)}], "Input"],

Cell[TextData[{
  "We can check that this lies on the light cone by calculating ",
  Cell[BoxData[
      RowBox[{"u", ".", "u"}]]],
  " in the red frame."
}], "Text"],

Cell[BoxData[{
    \(\[Eta]dd[i, j] xu[i] xu[j] // ToFlavor[red]\), "\[IndentingNewLine]", 
    \(\(% // EinsteinSum[]\) // Simplify\)}], "Input"],

Cell[TextData[{
  "Let ",
  Cell[BoxData["\[Phi]"]],
  " be the angle as measured in the red frame. Then..."
}], "Text"],

Cell[BoxData[
    \(step1 = Tan[\[Phi]] == zred/xred\)], "Input"],

Cell[TextData[{
  "To obtain the ",
  StyleBox["Gravitation",
    FontSlant->"Italic"],
  " book formulas for ",
  Cell[BoxData[
      RowBox[{"Sin", "[", "\[Phi]", "]"}]]],
  " and ",
  Cell[BoxData[
      RowBox[{"Cos", "[", "\[Phi]", "]"}]]],
  " we need to do a little manipulation."
}], "Text"],

Cell[BoxData[{
    \(zred/\@\(xred\^2 + zred\^2\)\), "\[IndentingNewLine]", 
    \(FullSimplify[%, \(-1\) < \[Beta] < 1]\), "\[IndentingNewLine]", 
    \(% /. x_/\((\[Beta]\^2 - 
              1)\) \[Rule] \(-x\)/\((1 - \[Beta]\^2)\)\), \
"\[IndentingNewLine]", 
    \(Sin[\[Phi]] == % // PowerExpand\)}], "Input"],

Cell[BoxData[{
    \(xred/\@\(xred\^2 + zred\^2\)\), "\[IndentingNewLine]", 
    \(FullSimplify[%, \(-1\) < \[Beta] < 1]\), "\[IndentingNewLine]", 
    \(Cos[\[Phi]] == % // PowerExpand\)}], "Input"],

Cell["\<\
For a star directly overhead the angle in the red frame is...\
\>", "Text"],

Cell[BoxData[{
    \(step1\), "\[IndentingNewLine]", 
    \(% /. \[Theta] \[Rule] \[Pi]/2\)}], "Input"],

Cell[TextData[{
  "The nonrelativistic value is ",
  Cell[BoxData[
      \(1/\[Beta]\)]],
  " but unfortunately MTW have picked their angle in an inconvenient manner \
for observing overhead."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Aberration of Starlight for Overhead Star", "Subsection"],

Cell["This time we use the angle from the z axis.", "Text"],

Cell["\<\
We are observing a star from the red frame moving in the positive x \
direction...\
\>", "Text"],

Cell[BoxData[
    \(\(LorentzMatrixValues[\[CapitalLambda], red]\)[\[Beta], 0, 
      0]\)], "Input"],

Cell[TextData[{
  "In the rest frame, with respect to the star, we specify an event on the \
past light cone in the direction of the star. ",
  Cell[BoxData["\[Theta]"]],
  " is the angle from the z axis."
}], "Text"],

Cell[BoxData[
    \(SetTensorValues[
      xu[i], {\(-1\), Sin[\[Theta]], 0, Cos[\[Theta]]}]\)], "Input"],

Cell["Transforming the event to the moving red frame...", "Text"],

Cell[BoxData[{
    \(\[CapitalLambda]ud[red@i, j] xu[j]\), "\[IndentingNewLine]", 
    \(% // EinsteinSum[]\), "\[IndentingNewLine]", 
    \({tred, xred, yred, zred} = \(% // EinsteinArray[]\) // 
        Simplify\), "\[IndentingNewLine]", 
    \(SetTensorValues[xu[red@i], %]\)}], "Input"],

Cell[TextData[{
  "Let ",
  Cell[BoxData["\[Phi]"]],
  " be the angle as measured in the red frame. Then..."
}], "Text"],

Cell[BoxData[
    \(step1 = Tan[\[Phi]] == xred/zred\)], "Input"],

Cell["For an overhead star...", "Text"],

Cell[BoxData[
    \(step1 /. \[Theta] \[Rule] 0\)], "Input"],

Cell[TextData[{
  "The nonrelativistic value is ",
  Cell[BoxData[
      \(\[Beta]\)]],
  ". Calculating the relativistic angle in radians..."
}], "Text"],

Cell[BoxData[{
    \(step1 /. \[Theta] \[Rule] 0\), "\[IndentingNewLine]", 
    \(step2 = ArcTan /@ % // PowerExpand\)}], "Input"],

Cell[TextData[{
  "For small ",
  Cell[BoxData["\[Beta]"]],
  " we can use a series expansion. For the nonrelativistic calculation the \
angle is..."
}], "Text"],

Cell[BoxData[
    \(Series[ArcTan[\[Beta]], {\[Beta], 0, 6}]\)], "Input"],

Cell["For the relativistic case it is...", "Text"],

Cell[BoxData[
    \(Series[
      step2\_\(\(\[LeftDoubleBracket]\)\(2\)\(\[RightDoubleBracket]\)\), {\
\[Beta], 0, 6}]\)], "Input"],

Cell[TextData[{
  "The difference is ",
  Cell[BoxData[
      RowBox[{
        RowBox[{"1", "/", "2"}], 
        SuperscriptBox["\[Beta]", "3"]}]]],
  ".  For the earth in orbit about the sun, ",
  Cell[BoxData["\[Beta]"]],
  " is about ",
  Cell[BoxData["0.001"]],
  ". So the abberation in radians, and the relativistic correction are..."
}], "Text"],

Cell[BoxData[{
    \({\[Beta], \[Beta]\^3/2}\), "\[IndentingNewLine]", 
    \(% /. \[Beta] \[Rule] 0.001\)}], "Input"],

Cell[TextData[{
  "The difference is too small to measure. The importance of aberration to \
relativity is that it shows that the putative ether is not dragged around \
with the earth, else there would be no (or less) aberration, which ",
  StyleBox["can",
    FontSlant->"Italic"],
  " be measured"
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["4-Velocity", "Subsection"],

Cell["From Box 2.2: Worked Exercises Using the Metric.", "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "Show that the squared length of a particle's 4-velocity is ",
  Cell[BoxData[
      RowBox[{"-", "1"}]]],
  " in any frame."
}], "Subsubsection"],

Cell["Calculate it in the rest frame of the particle.", "Text"],

Cell[BoxData[{
    \(SetTensorValues[uu[red@i], {1, 0, 0, 0}]\), "\[IndentingNewLine]", 
    \(\[Eta]dd[i, j] uu[i] uu[j] // ToFlavor[red]\), "\[IndentingNewLine]", 
    \(% // EinsteinSum[]\)}], "Input"],

Cell["\<\
Since the squared length is a geometric invariant it will be the same in any \
frame. But let's check it out.\
\>", "Text"],

Cell[TextData[{
  "Calculate and store the components in the rest frame if the particle is \
moving with speed ",
  Cell[BoxData["\[Beta]"]],
  " in the direction ",
  Cell[BoxData[
      RowBox[{"\[Phi]", ",", "\[Theta]"}]]],
  "."
}], "Text"],

Cell[BoxData[
    \(\(LorentzMatrixValues[\[CapitalLambda], 
        red]\)[\[Beta], \[Phi], \[Theta]]\)], "Input"],

Cell[BoxData[{
    \(\[CapitalLambda]ud[i, red@j] uu[red@j]\), "\[IndentingNewLine]", 
    \(% // ToArrayValues[]\), "\[IndentingNewLine]", 
    \(SetTensorValues[uu[i], %]\)}], "Input"],

Cell["Then calculate the squared length.", "Text"],

Cell[BoxData[{
    \(\[Eta]dd[i, j] uu[i] uu[j]\), "\[IndentingNewLine]", 
    \(\(% // EinsteinSum[]\) // Simplify\)}], "Input"],

Cell[TextData[{
  "We can also break the expansion of ",
  Cell[BoxData[
      RowBox[{"u", ".", "u"}]]],
  " into the time component and the space component."
}], "Text"],

Cell[BoxData[{
    \(usquare = \[Eta]dd[i, j] uu[i] uu[j]\), "\[IndentingNewLine]", 
    \(timecomponent = usquare // EinsteinSum[{0}]\), "\[IndentingNewLine]", 
    \(spacecomponent = \(usquare // EinsteinSum[{1, 2, 3}]\) // 
        Simplify\), "\[IndentingNewLine]", 
    \(timecomponent + spacecomponent\), "\[IndentingNewLine]", 
    \(% // Simplify\)}], "Input"],

Cell[TextData[{
  "We can also break ",
  Cell[BoxData["u"]],
  " into the time component and the spatial ",
  StyleBox["vector",
    FontWeight->"Bold"],
  " and then use the dot product."
}], "Text"],

Cell[BoxData[{
    \(timecomponent = uu[0]\), "\[IndentingNewLine]", 
    \(spacecomponent = uu[i] // EinsteinArray[{1, 2, 3}]\)}], "Input"],

Cell["Then the squared length using the metric is", "Text"],

Cell[BoxData[{
    \(HoldForm[\((\(-timecomponent\^2\) + 
          spacecomponent . spacecomponent)\)]\), "\[IndentingNewLine]", 
    \(\(% // ReleaseHold\) // Simplify\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Show the relation between rest mass, energy and momentum", \
"Subsubsection"],

Cell[TextData[{
  "The 4-momentum is defined by ",
  Cell[BoxData[
      RowBox[{"p", "\[Equal]", 
        RowBox[{"m", " ", "u"}]}]]],
  " where ",
  Cell[BoxData["u"]],
  " is the 4-velocity and ",
  Cell[BoxData["m"]],
  " is the rest mass. It's squared length in the particle frame is..."
}], "Text"],

Cell[BoxData[{
    \(\(m\^2\) \[Eta]dd[i, j] uu[i] uu[j] // 
      ToFlavor[red]\), "\[IndentingNewLine]", 
    \(% // EinsteinSum[]\)}], "Input"],

Cell[TextData[{
  "In the rest frame we can calculate the time part (",
  Cell[BoxData["En"]],
  ") and the space part, ",
  Cell[BoxData["ps"]],
  ". (We can't use ",
  Cell[BoxData["E"]],
  " because it is reserved in ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " and we are using ",
  Cell[BoxData["p"]],
  " for the 4-momentum. So I have used ",
  Cell[BoxData["En"]],
  " and ",
  Cell[BoxData["ps"]],
  " for the energy and spatial momentum.)"
}], "Text"],

Cell[BoxData[{
    \(En = m\ uu[0]\), "\[IndentingNewLine]", 
    \(ps = m\ uu[i] // EinsteinArray[{1, 2, 3}]\)}], "Input"],

Cell[BoxData[{
    \(HoldForm[m\^2 == En\^2 - ps . ps]\), "\[IndentingNewLine]", 
    \(% // ReleaseHold\), "\[IndentingNewLine]", 
    \(% // Simplify\)}], "Input"],

Cell["Clear values.", "Text"],

Cell[BoxData[{
    \(ClearTensorValues[{uu[i], uu[red@i], xu[i], 
        xu[red@i], \[Eta]dd[i, j], \[Eta]uu[i, j], \[Eta]dd[red@i, 
          red@j], \[Eta]uu[red@i, red@j], \[CapitalLambda]ud[i, 
          red@j], \[CapitalLambda]ud[red@i, j], dxd[i], dxu[i]}]\), "\n", 
    \(ClearTensorShortcuts[{{u, x, dx}, 1}, {{\[Eta], \[CapitalLambda]}, 
        2}]\), "\n", 
    \(Clear[En, ps, timecomponent, spacecomponent, tred, xred, yred, zred, 
      usquare, step1, step2]\)}], "Input"]
}, Closed]]
}, Closed]]
}, Open  ]]
}, Open  ]]
},
FrontEndVersion->"4.2 for Microsoft Windows",
ScreenRectangle->{{0, 1280}, {0, 943}},
AutoGeneratedPackage->None,
WindowToolbars->{},
WindowSize->{714, 690},
WindowMargins->{{0, Automatic}, {Automatic, 0}},
ShowSelection->True,
StyleDefinitions -> "TensorialStyle.nb"
]

(*******************************************************************
Cached data follows.  If you edit this Notebook file directly, not
using Mathematica, you must remove the line containing CacheID at
the top of  the file.  The cache data will then be recreated when
you save this file from within Mathematica.
*******************************************************************)

(*CellTagsOutline
CellTagsIndex->{}
*)

(*CellTagsIndex
CellTagsIndex->{}
*)

(*NotebookFileOutline
Notebook[{

Cell[CellGroupData[{
Cell[1776, 53, 43, 0, 76, "Title"],
Cell[1822, 55, 172, 5, 75, "Chaptertitle"],
Cell[1997, 62, 60, 3, 61, "Subsubtitle"],
Cell[2060, 67, 324, 9, 74, "Text"],
Cell[2387, 78, 133, 3, 34, "Text"],

Cell[CellGroupData[{
Cell[2545, 85, 33, 0, 61, "Section"],
Cell[2581, 87, 100, 2, 46, "Input",
  InitializationCell->True],
Cell[2684, 91, 90, 2, 34, "Text"],
Cell[2777, 95, 183, 3, 66, "Input",
  InitializationCell->True],
Cell[2963, 100, 47, 0, 34, "Text"],
Cell[3013, 102, 326, 6, 86, "Input",
  InitializationCell->True],
Cell[3342, 110, 73, 0, 34, "Text"],
Cell[3418, 112, 100, 2, 46, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[3555, 119, 68, 0, 41, "Section"],
Cell[3626, 121, 2729, 45, 567, "Input",
  InitializationCell->True],
Cell[6358, 168, 2726, 45, 567, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[9121, 218, 27, 0, 41, "Section"],

Cell[CellGroupData[{
Cell[9173, 222, 78, 0, 49, "Subsection"],
Cell[9254, 224, 57, 1, 46, "Input"],
Cell[9314, 227, 45, 0, 34, "Text"],
Cell[9362, 229, 219, 4, 86, "Input"],
Cell[9584, 235, 59, 0, 34, "Text"],
Cell[9646, 237, 123, 2, 66, "Input"],
Cell[9772, 241, 45, 0, 34, "Text"],
Cell[9820, 243, 123, 2, 66, "Input"],
Cell[9946, 247, 45, 0, 34, "Text"],
Cell[9994, 249, 225, 4, 86, "Input"],
Cell[10222, 255, 45, 0, 34, "Text"],
Cell[10270, 257, 225, 4, 86, "Input"],
Cell[10498, 263, 52, 0, 34, "Text"],
Cell[10553, 265, 233, 4, 86, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[10823, 274, 51, 0, 33, "Subsection"],
Cell[10877, 276, 87, 2, 34, "Text"],
Cell[10967, 280, 264, 5, 86, "Input"],
Cell[11234, 287, 38, 0, 34, "Text"],
Cell[11275, 289, 278, 5, 86, "Input"],
Cell[11556, 296, 320, 9, 54, "Text"],
Cell[11879, 307, 336, 6, 106, "Input"],
Cell[12218, 315, 432, 10, 74, "Text"],
Cell[12653, 327, 460, 8, 146, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[13150, 340, 57, 0, 33, "Subsection"],
Cell[13210, 342, 136, 3, 34, "Text"],
Cell[13349, 347, 115, 2, 46, "Input"],
Cell[13467, 351, 197, 3, 66, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[13701, 359, 53, 0, 33, "Subsection"],
Cell[13757, 361, 143, 3, 34, "Text"],
Cell[13903, 366, 115, 2, 46, "Input"],
Cell[14021, 370, 258, 6, 86, "Input"],
Cell[14282, 378, 53, 0, 34, "Text"],
Cell[14338, 380, 249, 5, 86, "Input"],
Cell[14590, 387, 375, 7, 74, "Text"],
Cell[14968, 396, 277, 7, 54, "Text"],
Cell[15248, 405, 466, 9, 146, "Input"],
Cell[15717, 416, 311, 5, 74, "Text"],
Cell[16031, 423, 451, 8, 146, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[16519, 436, 289, 7, 74, "Subsection"],
Cell[16811, 445, 139, 3, 54, "Text"],
Cell[16953, 450, 224, 4, 86, "Input"],
Cell[17180, 456, 115, 2, 66, "Input"],
Cell[17298, 460, 123, 3, 34, "Text"],
Cell[17424, 465, 183, 4, 66, "Input"],
Cell[17610, 471, 324, 7, 74, "Text"],
Cell[17937, 480, 293, 5, 66, "Input"],
Cell[18233, 487, 224, 4, 54, "Text"],
Cell[18460, 493, 258, 5, 74, "Text"],
Cell[18721, 500, 476, 8, 86, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[19234, 513, 42, 0, 33, "Subsection"],
Cell[19279, 515, 160, 3, 54, "Text"],
Cell[19442, 520, 111, 2, 46, "Input"],
Cell[19556, 524, 73, 1, 46, "Input"],
Cell[19632, 527, 148, 3, 54, "Text"],
Cell[19783, 532, 162, 2, 66, "Input"],
Cell[19948, 536, 102, 3, 34, "Text"],
Cell[20053, 541, 57, 1, 46, "Input"],
Cell[20113, 544, 31, 0, 34, "Text"],
Cell[20147, 546, 133, 3, 34, "Text"],
Cell[20283, 551, 61, 1, 46, "Input"],
Cell[20347, 554, 200, 6, 54, "Text"],
Cell[20550, 562, 130, 4, 34, "Text"],
Cell[20683, 568, 69, 1, 46, "Input"],
Cell[20755, 571, 61, 0, 34, "Text"],
Cell[20819, 573, 225, 4, 86, "Input"],
Cell[21047, 579, 111, 3, 34, "Text"],
Cell[21161, 584, 57, 1, 46, "Input"],
Cell[21221, 587, 416, 11, 74, "Text"],
Cell[21640, 600, 128, 2, 66, "Input"],
Cell[21771, 604, 265, 7, 54, "Text"],
Cell[22039, 613, 353, 7, 107, "Input"],
Cell[22395, 622, 161, 3, 54, "Text"],
Cell[22559, 627, 77, 1, 46, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[22673, 633, 69, 0, 33, "Subsection"],
Cell[22745, 635, 53, 0, 34, "Text"],
Cell[22801, 637, 214, 4, 66, "Input"],
Cell[23018, 643, 120, 4, 34, "Text"],
Cell[23141, 649, 75, 1, 46, "Input"],
Cell[23219, 652, 135, 3, 34, "Text"],
Cell[23357, 657, 363, 6, 126, "Input"],
Cell[23723, 665, 73, 0, 34, "Text"],
Cell[23799, 667, 66, 1, 46, "Input"],
Cell[23868, 670, 75, 0, 34, "Text"],
Cell[23946, 672, 78, 1, 46, "Input"],
Cell[24027, 675, 59, 0, 34, "Text"],
Cell[24089, 677, 275, 5, 86, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[24401, 687, 63, 0, 33, "Subsection"],
Cell[24467, 689, 106, 3, 34, "Text"],
Cell[24576, 694, 101, 2, 46, "Input"],
Cell[24680, 698, 220, 5, 54, "Text"],
Cell[24903, 705, 105, 2, 46, "Input"],
Cell[25011, 709, 62, 0, 34, "Text"],
Cell[25076, 711, 129, 2, 66, "Input"],
Cell[25208, 715, 65, 0, 34, "Text"],
Cell[25276, 717, 290, 5, 106, "Input"],
Cell[25569, 724, 166, 5, 34, "Text"],
Cell[25738, 731, 146, 2, 66, "Input"],
Cell[25887, 735, 120, 4, 34, "Text"],
Cell[26010, 741, 65, 1, 46, "Input"],
Cell[26078, 744, 299, 11, 34, "Text"],
Cell[26380, 757, 314, 6, 110, "Input"],
Cell[26697, 765, 199, 3, 90, "Input"],
Cell[26899, 770, 85, 2, 34, "Text"],
Cell[26987, 774, 103, 2, 66, "Input"],
Cell[27093, 778, 204, 6, 54, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[27334, 789, 63, 0, 33, "Subsection"],
Cell[27400, 791, 59, 0, 34, "Text"],
Cell[27462, 793, 106, 3, 34, "Text"],
Cell[27571, 798, 101, 2, 46, "Input"],
Cell[27675, 802, 217, 5, 54, "Text"],
Cell[27895, 809, 105, 2, 46, "Input"],
Cell[28003, 813, 65, 0, 34, "Text"],
Cell[28071, 815, 290, 5, 106, "Input"],
Cell[28364, 822, 120, 4, 34, "Text"],
Cell[28487, 828, 65, 1, 46, "Input"],
Cell[28555, 831, 39, 0, 34, "Text"],
Cell[28597, 833, 60, 1, 46, "Input"],
Cell[28660, 836, 154, 5, 34, "Text"],
Cell[28817, 843, 130, 2, 66, "Input"],
Cell[28950, 847, 161, 5, 34, "Text"],
Cell[29114, 854, 73, 1, 46, "Input"],
Cell[29190, 857, 50, 0, 34, "Text"],
Cell[29243, 859, 132, 3, 47, "Input"],
Cell[29378, 864, 352, 11, 54, "Text"],
Cell[29733, 877, 118, 2, 66, "Input"],
Cell[29854, 881, 311, 7, 74, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[30202, 893, 32, 0, 33, "Subsection"],
Cell[30237, 895, 64, 0, 34, "Text"],

Cell[CellGroupData[{
Cell[30326, 899, 164, 5, 43, "Subsubsection"],
Cell[30493, 906, 63, 0, 34, "Text"],
Cell[30559, 908, 204, 3, 86, "Input"],
Cell[30766, 913, 133, 3, 34, "Text"],
Cell[30902, 918, 244, 8, 54, "Text"],
Cell[31149, 928, 115, 2, 46, "Input"],
Cell[31267, 932, 186, 3, 86, "Input"],
Cell[31456, 937, 50, 0, 34, "Text"],
Cell[31509, 939, 129, 2, 66, "Input"],
Cell[31641, 943, 171, 5, 34, "Text"],
Cell[31815, 950, 368, 6, 126, "Input"],
Cell[32186, 958, 201, 7, 35, "Text"],
Cell[32390, 967, 140, 2, 66, "Input"],
Cell[32533, 971, 59, 0, 34, "Text"],
Cell[32595, 973, 183, 3, 66, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[32815, 981, 83, 1, 29, "Subsubsection"],
Cell[32901, 984, 304, 10, 54, "Text"],
Cell[33208, 996, 146, 3, 66, "Input"],
Cell[33357, 1001, 474, 17, 74, "Text"],
Cell[33834, 1020, 123, 2, 66, "Input"],
Cell[33960, 1024, 165, 3, 86, "Input"],
Cell[34128, 1029, 29, 0, 34, "Text"],
Cell[34160, 1031, 488, 8, 146, "Input"]
}, Closed]]
}, Closed]]
}, Open  ]]
}, Open  ]]
}
]
*)



(*******************************************************************
End of Mathematica Notebook file.
*******************************************************************)

